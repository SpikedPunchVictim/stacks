"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Orchestrator = void 0;
const events_1 = require("../events");
const SaveObjectEvent_1 = require("../events/SaveObjectEvent");
const DeleteObjectEvent_1 = require("../events/DeleteObjectEvent");
const Event_1 = require("../events/Event");
const GetManyObjectsEvent_1 = require("../events/GetManyObjectsEvent");
const HasIdEvent_1 = require("../events/HasIdEvent");
const UpdateObjectEvent_1 = require("../events/UpdateObjectEvent");
const ProxyObject_1 = require("../ProxyObject");
const UidKeeper_1 = require("../UidKeeper");
const CreateObjectEvent_1 = require("../events/CreateObjectEvent");
class Orchestrator {
    constructor(context) {
        this.context = context;
    }
    get cache() {
        return this.context.cache;
    }
    get rfc() {
        return this.context.rfc;
    }
    get serializer() {
        return this.context.serializer;
    }
    get stack() {
        return this.context.stack;
    }
    get uid() {
        return this.context.uid;
    }
    async createObject(model, params) {
        let created = await ProxyObject_1.ProxyObject.fromCreated(model, params, this.context);
        await this.rfc.create(new CreateObjectEvent_1.CreateObjectEvent(model, created))
            .fulfill(async (event) => {
            await this.stack.emit(Event_1.EventSet.ObjectCreated, event);
        })
            .commit();
        return created;
    }
    /**
     *
     * @param model The Model
     * @param obj The Object to save. Note that this is really a Proxy'd SerializableObject
     */
    async saveObject(model, obj) {
        if (obj.id === UidKeeper_1.UidKeeper.IdNotSet) {
            obj.id = await this.uid.generate();
        }
        let validations = await model.validate(obj);
        if (!validations.success) {
            throw new Error(`Cannot Save Object with ID ${obj.id} since it fails validation. Reason: ${validations.results.map(r => r.error)}`);
        }
        //@ts-ignore
        let serialized = ProxyObject_1.ProxyObject.unwrap(obj);
        await this.rfc.create(new SaveObjectEvent_1.SaveObjectEvent(model, obj, serialized))
            .fulfill(async (event) => {
            this.cache.saveObject(model, obj);
            await this.stack.emit(Event_1.EventSet.SaveObject, event);
        })
            .commit();
    }
    async getManyObjects(model, options = {}) {
        let results = {
            cursor: '',
            items: new Array()
        };
        await this.rfc.create(new GetManyObjectsEvent_1.GetManyObjectsEvent(model, options))
            .fulfill(async (event) => {
            let cast = event;
            await this.stack.emit(Event_1.EventSet.GetManyObjects, cast);
            if (cast.results !== undefined) {
                results = cast.results;
                return;
            }
            let objects = this.cache.getObjects(model);
            if (objects.length == 0) {
                return;
            }
            let cursor = options.cursor || '';
            let limit = options.limit || 100;
            // Sort by ID. The resulting paged set is not perfect, and will have
            // holes when new entries are added in between queries.
            objects.sort((a, b) => {
                let aId = a.id.toLowerCase();
                let bId = b.id.toLowerCase();
                return (aId < bId) ? -1 : (aId > bId) ? 1 : 0;
            });
            if (cursor === '') {
                // For an empty cursor we start from the beginning
                let items = objects.slice(0, Math.min(objects.length, limit));
                if (items.length == limit && objects.length > limit) {
                    results.cursor = Buffer.from(objects[limit].id).toString('base64');
                }
                else {
                    // If there are no more entries in thenext set, we default the cursor
                    // to empty string
                    results.cursor = '';
                }
                results.items = items;
                return;
            }
            else {
                // We have a cursor and continue from whence we left off
                cursor = Buffer.from(cursor, 'base64').toString('ascii');
                let index = objects.findIndex(o => o.id === cursor);
                if (index === -1) {
                    // We get here when the object that's next has been deleted
                    // return early
                    return;
                }
                let nextIndex = index + limit;
                results.items = objects.slice(index, nextIndex);
                if (objects.length > nextIndex) {
                    results.cursor = Buffer.from(objects[nextIndex].id).toString('base64');
                }
                else {
                    // If there are no more entries in the next set, we default the cursor
                    // to empty string
                    results.cursor = '';
                }
                return;
            }
            return;
        })
            .commit();
        return results;
    }
    async deleteObject(model, obj) {
        await this.rfc.create(new DeleteObjectEvent_1.DeleteObjectEvent(model, obj))
            .fulfill(async (event) => {
            this.cache.deleteObject(model, obj);
            await this.stack.emit(Event_1.EventSet.ObjectDeleted, event);
        })
            .commit();
    }
    async getObject(model, id) {
        let object;
        await this.rfc.create(new events_1.GetObjectEvent(model, id))
            .fulfill(async (event) => {
            let cast = event;
            if (cast.object === undefined) {
                object = cast.exists === Event_1.ExistState.DoesNotExist ?
                    undefined :
                    this.cache.getObject(model, id);
            }
            else {
                // We get a serialized version of the Object
                let serialized = await ProxyObject_1.ProxyObject.fromStored(model, cast.object, this.context.serializer);
                this.cache.saveObject(model, serialized);
                //@ts-ignore
                object = serialized;
            }
            await this.stack.emit(Event_1.EventSet.GetObject, event);
        })
            .commit();
        return object;
    }
    async hasId(id) {
        let hasId = false;
        await this.rfc.create(new HasIdEvent_1.HasIdEvent(id))
            .fulfill(async (event) => {
            let cast = event;
            await this.stack.emit(Event_1.EventSet.HasId, event);
            if (cast.hasId) {
                hasId = true;
                return;
            }
            // Has it a plugin attempted to set it?
            if (cast.attemptedSet) {
                // If so, we can trust that an external system doesn't have it
                hasId = false;
                return;
            }
            // If no external system attempted to set it, do we have it cached?
            hasId = this.cache.hasId(id);
        })
            .commit();
        return hasId;
    }
    async updateObject(model, obj, onUpdate) {
        await this.rfc.create(new UpdateObjectEvent_1.UpdateObjectEvent(model, obj))
            .fulfill(async (event) => {
            let cast = event;
            let updated = cast.updated;
            await onUpdate(updated, cast.exists);
            await this.stack.emit(Event_1.EventSet.ObjectUpdated, event);
        })
            .commit();
    }
}
exports.Orchestrator = Orchestrator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT3JjaGVzdHJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL29yY2hlc3RyYXRvci9PcmNoZXN0cmF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEsc0NBQTJDO0FBQzNDLCtEQUE0RDtBQUM1RCxtRUFBZ0U7QUFDaEUsMkNBQXVEO0FBQ3ZELHVFQUFvRTtBQUNwRSxxREFBa0Q7QUFFbEQsbUVBQWdFO0FBS2hFLGdEQUE2QztBQUM3Qyw0Q0FBcUQ7QUFFckQsbUVBQWdFO0FBZ0VoRSxNQUFhLFlBQVk7SUFxQnRCLFlBQXFCLE9BQXNCO1FBQXRCLFlBQU8sR0FBUCxPQUFPLENBQWU7SUFFM0MsQ0FBQztJQXRCRCxJQUFJLEtBQUs7UUFDTixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFBO0lBQzVCLENBQUM7SUFFRCxJQUFJLEdBQUc7UUFDSixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFBO0lBQzFCLENBQUM7SUFFRCxJQUFJLFVBQVU7UUFDWCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFBO0lBQ2pDLENBQUM7SUFFRCxJQUFJLEtBQUs7UUFDTixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFBO0lBQzVCLENBQUM7SUFFRCxJQUFJLEdBQUc7UUFDSixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFBO0lBQzFCLENBQUM7SUFNRCxLQUFLLENBQUMsWUFBWSxDQUF3QixLQUFhLEVBQUUsTUFBMEI7UUFDaEYsSUFBSSxPQUFPLEdBQUcsTUFBTSx5QkFBVyxDQUFDLFdBQVcsQ0FBSSxLQUFLLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQU0sQ0FBQTtRQUVoRixNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUkscUNBQWlCLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBQ3hELE9BQU8sQ0FBQyxL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InNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFN0YWNrT2JqZWN0IH0gZnJvbSBcIi4uL1N0YWNrT2JqZWN0XCI7XG5pbXBvcnQgeyBJQ2FjaGUgfSBmcm9tIFwiLi4vQ2FjaGVcIjtcbmltcG9ydCB7IEdldE9iamVjdEV2ZW50IH0gZnJvbSBcIi4uL2V2ZW50c1wiO1xuaW1wb3J0IHsgU2F2ZU9iamVjdEV2ZW50IH0gZnJvbSBcIi4uL2V2ZW50cy9TYXZlT2JqZWN0RXZlbnRcIjtcbmltcG9ydCB7IERlbGV0ZU9iamVjdEV2ZW50IH0gZnJvbSBcIi4uL2V2ZW50cy9EZWxldGVPYmplY3RFdmVudFwiO1xuaW1wb3J0IHsgRXZlbnRTZXQsIEV4aXN0U3RhdGUgfSBmcm9tIFwiLi4vZXZlbnRzL0V2ZW50XCI7XG5pbXBvcnQgeyBHZXRNYW55T2JqZWN0c0V2ZW50IH0gZnJvbSBcIi4uL2V2ZW50cy9HZXRNYW55T2JqZWN0c0V2ZW50XCI7XG5pbXBvcnQgeyBIYXNJZEV2ZW50IH0gZnJvbSBcIi4uL2V2ZW50cy9IYXNJZEV2ZW50XCI7XG5pbXBvcnQgeyBJUmVxdWVzdEZvckNoYW5nZVNvdXJjZSB9IGZyb20gXCIuLi9ldmVudHMvUmVxdWVzdEZvckNoYW5nZVwiO1xuaW1wb3J0IHsgVXBkYXRlT2JqZWN0RXZlbnQgfSBmcm9tIFwiLi4vZXZlbnRzL1VwZGF0ZU9iamVjdEV2ZW50XCI7XG5pbXBvcnQgeyBJTW9kZWwsIE9iamVjdENyZWF0ZVBhcmFtcywgUGFnZVJlcXVlc3QsIFBhZ2VSZXNwb25zZSB9IGZyb20gXCIuLi9Nb2RlbFwiO1xuaW1wb3J0IHsgSVN0YWNrIH0gZnJvbSBcIi4uL3N0YWNrL1N0YWNrXCI7XG5pbXBvcnQgeyBJU3RhY2tDb250ZXh0IH0gZnJvbSBcIi4uL3N0YWNrL1N0YWNrQ29udGV4dFwiO1xuaW1wb3J0IHsgVXBkYXRlT2JqZWN0SGFuZGxlciB9IGZyb20gXCIuLi9zdGFjay9TdGFja1VwZGF0ZVwiO1xuaW1wb3J0IHsgUHJveHlPYmplY3QgfSBmcm9tIFwiLi4vUHJveHlPYmplY3RcIjtcbmltcG9ydCB7IElVaWRLZWVwZXIsIFVpZEtlZXBlciB9IGZyb20gXCIuLi9VaWRLZWVwZXJcIjtcbmltcG9ydCB7IElWYWx1ZVNlcmlhbGl6ZXIgfSBmcm9tIFwiLi4vc2VyaWFsaXplL1ZhbHVlU2VyaWFsaXplclwiO1xuaW1wb3J0IHsgQ3JlYXRlT2JqZWN0RXZlbnQgfSBmcm9tIFwiLi4vZXZlbnRzL0NyZWF0ZU9iamVjdEV2ZW50XCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSU9yY2hlc3RyYXRvciB7XG4gICAvLyBUT0RPOiBBZGQ6IGNyZWF0ZU1vZGVsLCBkZWxldGVNb2RlbCAodGhlc2Ugc2hvdWxkIGFzc2lzdCBpbiBydW5uaW5nIHRlc3RzKVxuXG4gICAvKipcbiAgICAqIENyZWF0ZXMgYSBuZXcgT2JqZWN0IGluIG1lbW9yeSBvbmx5LiBOb3QgaW5kZW5kZWQgdG8gYmUgc3RvcmVkIG9uIHRoZSBiYWNrZW5kLlxuICAgICogT2JqZWN0cyBjcmVhdGVkIHRoaXMgd2F5IGhhdmUgbm8gSUQgYXNzaWduZWQgdG8gdGhlbSB1bnRpbCB0aGV5IGFyZSBzYXZlZC5cbiAgICAqIFxuICAgICogQHBhcmFtIG1vZGVsIFRoZSBNb2RlbFxuICAgICogQHBhcmFtIHBhcmFtcyBUaGUgT2JqZWN0IENyZWF0aW9uIFBhcmFtcyBcbiAgICAqL1xuICAgY3JlYXRlT2JqZWN0PFQgZXh0ZW5kcyBTdGFja09iamVjdD4obW9kZWw6IElNb2RlbCwgcGFyYW1zOiBPYmplY3RDcmVhdGVQYXJhbXMpOiBQcm9taXNlPFQ+XG5cbiAgIC8qKlxuICAgICogU2F2ZXMgYW4gT2JqZWN0IHRvIHRoZSBiYWNrZW5kLlxuICAgICogXG4gICAgKiBAcGFyYW0gbW9kZWwgVGhlIE1vZGVsXG4gICAgKiBAcGFyYW0gb2JqIFRoZSBPYmplY3QgdG8gU2F2ZVxuICAgICovXG4gICBzYXZlT2JqZWN0PFQgZXh0ZW5kcyBTdGFja09iamVjdD4obW9kZWw6IElNb2RlbCwgb2JqOiBUKTogUHJvbWlzZTx2b2lkPlxuXG4gICAvKipcbiAgICAqIERlbGV0ZXMgYW4gT2JqZWN0IGZyb20gdGhlIGJhY2tlbmRcbiAgICAqIFxuICAgICogQHBhcmFtIG1vZGVsIFRoZSBNb2RlbFxuICAgICogQHBhcmFtIG9iaiBUaGUgT2JqZWN0IHRvIGRlbGV0ZVxuICAgICovXG4gICBkZWxldGVPYmplY3Q8VCBleHRlbmRzIFN0YWNrT2JqZWN0Pihtb2RlbDogSU1vZGVsLCBvYmo6IFQpOiBQcm9taXNlPHZvaWQ+XG5cbiAgIC8qKlxuICAgICogUmV0cmlldmVzIG1hbnkgb2JqZWN0cyBpbiBhIHBhZ2VkIGZhc2hpb24uXG4gICAgKiBcbiAgICAqIEBwYXJhbSBtb2RlbCBUaGUgTW9kZWwgcmVwcmVzZW50aW5nIHRoZSBPYmplY3RzXG4gICAgKiBAcGFyYW0gb3B0aW9ucyBQYWdlUmVxdWVzdCBPcHRpb25zXG4gICAgKi9cbiAgIGdldE1hbnlPYmplY3RzPFQgZXh0ZW5kcyBTdGFja09iamVjdD4obW9kZWw6IElNb2RlbCwgb3B0aW9uczogUGFnZVJlcXVlc3QpOiBQcm9taXNlPFBhZ2VSZXNwb25zZTxUPj5cbiAgIFxuICAgLyoqXG4gICAgKiBSZXRyaWV2ZXMgdGhlIEVkaXQgdmVyc2lvbiBvZiB0aGUgT2JqZWN0XG4gICAgKiBcbiAgICAqIEBwYXJhbSBtb2RlbCBUaGUgTW9kZWwgb2YgdGhlIE9iamVjdFxuICAgICogQHBhcmFtIGlkIFRoZSBPYmplY3QncyBJRFxuICAgICovXG4gICBnZXRPYmplY3Q8VCBleHRlbmRzIFN0YWNrT2JqZWN0Pihtb2RlbDogSU1vZGVsLCBpZDogc3RyaW5nKTogUHJvbWlzZTxUIHwgdW5kZWZpbmVkPlxuXG4gICAvKipcbiAgICAqIERldGVybWluZXMgaWYgYW4gSUQgaXMgYWxyZWFkeSBpbiB1c2UuXG4gICAgKiBcbiAgICAqIEBwYXJhbSBpZCBUaGUgSUQgdG8gdGVzdFxuICAgICovXG4gICBoYXNJZChpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPlxuICAgXG4gICAvKipcbiAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlcyBvZiBhbiBPYmplY3RcbiAgICAqIFxuICAgICogQHBhcmFtIG1vZGVsIFRoZSBNb2RlbCBvZiB0aGUgT2JqZWN0XG4gICAgKiBAcGFyYW0gb2JqIFRoZSBPYmplY3QgdG8gdXBkYXRlXG4gICAgKiBAcGFyYW0gb25VcGRhdGUgSGFuZGxlciB0aGF0IGlzIGNhbGxlZCBhZnRlciBhbiBPYmplY3QgaGFzIGJlZW4gdXBkYXRlZFxuICAgICovXG4gICB1cGRhdGVPYmplY3Q8VCBleHRlbmRzIFN0YWNrT2JqZWN0Pihtb2RlbDogSU1vZGVsLCBvYmo6IFQsIG9uVXBkYXRlOiBVcGRhdGVPYmplY3RIYW5kbGVyPFQ+KTogUHJvbWlzZTx2b2lkPlxufVxuXG5cbmV4cG9ydCBjbGFzcyBPcmNoZXN0cmF0b3IgaW1wbGVtZW50cyBJT3JjaGVzdHJhdG9yIHtcbiAgIGdldCBjYWNoZSgpOiBJQ2FjaGUge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5jYWNoZVxuICAgfVxuXG4gICBnZXQgcmZjKCk6IElSZXF1ZXN0Rm9yQ2hhbmdlU291cmNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQucmZjXG4gICB9XG5cbiAgIGdldCBzZXJpYWxpemVyKCk6IElWYWx1ZVNlcmlhbGl6ZXIge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5zZXJpYWxpemVyXG4gICB9XG5cbiAgIGdldCBzdGFjaygpOiBJU3RhY2sge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFja1xuICAgfVxuXG4gICBnZXQgdWlkKCk6IElVaWRLZWVwZXIge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC51aWRcbiAgIH1cblxuICAgY29uc3RydWN0b3IocmVhZG9ubHkgY29udGV4dDogSVN0YWNrQ29udGV4dCkge1xuXG4gICB9XG5cbiAgIGFzeW5jIGNyZWF0ZU9iamVjdDxUIGV4dGVuZHMgU3RhY2tPYmplY3Q+KG1vZGVsOiBJTW9kZWwsIHBhcmFtczogT2JqZWN0Q3JlYXRlUGFyYW1zKTogUHJvbWlzZTxUPiB7XG4gICAgICBsZXQgY3JlYXRlZCA9IGF3YWl0IFByb3h5T2JqZWN0LmZyb21DcmVhdGVkPFQ+KG1vZGVsLCBwYXJhbXMsIHRoaXMuY29udGV4dCkgYXMgVFxuXG4gICAgICBhd2FpdCB0aGlzLnJmYy5jcmVhdGUobmV3IENyZWF0ZU9iamVjdEV2ZW50KG1vZGVsLCBjcmVhdGVkKSlcbiAgICAgICAgIC5mdWxmaWxsKGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGFjay5lbWl0KEV2ZW50U2V0Lk9iamVjdENyZWF0ZWQsIGV2ZW50KVxuICAgICAgICAgfSlcbiAgICAgICAgIC5jb21taXQoKVxuXG4gICAgICByZXR1cm4gY3JlYXRlZFxuICAgfVxuXG4gICAvKipcbiAgICAqIFxuICAgICogQHBhcmFtIG1vZGVsIFRoZSBNb2RlbFxuICAgICogQHBhcmFtIG9iaiBUaGUgT2JqZWN0IHRvIHNhdmUuIE5vdGUgdGhhdCB0aGlzIGlzIHJlYWxseSBhIFByb3h5J2QgU2VyaWFsaXphYmxlT2JqZWN0XG4gICAgKi9cbiAgIGFzeW5jIHNhdmVPYmplY3Q8VCBleHRlbmRzIFN0YWNrT2JqZWN0Pihtb2RlbDogSU1vZGVsLCBvYmo6IFQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmKG9iai5pZCA9PT0gVWlkS2VlcGVyLklkTm90U2V0KSB7XG4gICAgICAgICBvYmouaWQgPSBhd2FpdCB0aGlzLnVpZC5nZW5lcmF0ZSgpXG4gICAgICB9XG4gICAgICBcbiAgICAgIGxldCB2YWxpZGF0aW9ucyA9IGF3YWl0IG1vZGVsLnZhbGlkYXRlKG9iailcblxuICAgICAgaWYgKCF2YWxpZGF0aW9ucy5zdWNjZXNzKSB7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBTYXZlIE9iamVjdCB3aXRoIElEICR7b2JqLmlkfSBzaW5jZSBpdCBmYWlscyB2YWxpZGF0aW9uLiBSZWFzb246ICR7dmFsaWRhdGlvbnMucmVzdWx0cy5tYXAociA9PiByLmVycm9yKX1gKVxuICAgICAgfVxuXG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIGxldCBzZXJpYWxpemVkID0gUHJveHlPYmplY3QudW53cmFwKG9iailcblxuICAgICAgYXdhaXQgdGhpcy5yZmMuY3JlYXRlKG5ldyBTYXZlT2JqZWN0RXZlbnQ8VD4obW9kZWwsIG9iaiwgc2VyaWFsaXplZCkpXG4gICAgICAgICAuZnVsZmlsbChhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2F2ZU9iamVjdChtb2RlbCwgb2JqKVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGFjay5lbWl0KEV2ZW50U2V0LlNhdmVPYmplY3QsIGV2ZW50KVxuICAgICAgICAgfSlcbiAgICAgICAgIC5jb21taXQoKVxuICAgfVxuXG4gICBhc3luYyBnZXRNYW55T2JqZWN0czxUIGV4dGVuZHMgU3RhY2tPYmplY3Q+KG1vZGVsOiBJTW9kZWwsIG9wdGlvbnM6IFBhZ2VSZXF1ZXN0ID0ge30pOiBQcm9taXNlPFBhZ2VSZXNwb25zZTxUPj4ge1xuICAgICAgbGV0IHJlc3VsdHMgPSB7XG4gICAgICAgICBjdXJzb3I6ICcnLFxuICAgICAgICAgaXRlbXM6IG5ldyBBcnJheTxUPigpXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRoaXMucmZjLmNyZWF0ZShuZXcgR2V0TWFueU9iamVjdHNFdmVudChtb2RlbCwgb3B0aW9ucykpXG4gICAgICAgICAuZnVsZmlsbChhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBjYXN0ID0gZXZlbnQgYXMgR2V0TWFueU9iamVjdHNFdmVudDxUPlxuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0YWNrLmVtaXQoRXZlbnRTZXQuR2V0TWFueU9iamVjdHMsIGNhc3QpXG5cbiAgICAgICAgICAgIGlmIChjYXN0LnJlc3VsdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgcmVzdWx0cyA9IGNhc3QucmVzdWx0c1xuICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBvYmplY3RzID0gdGhpcy5jYWNoZS5nZXRPYmplY3RzPFQ+KG1vZGVsKVxuXG4gICAgICAgICAgICBpZiAob2JqZWN0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSBvcHRpb25zLmN1cnNvciB8fCAnJ1xuICAgICAgICAgICAgbGV0IGxpbWl0ID0gb3B0aW9ucy5saW1pdCB8fCAxMDBcblxuICAgICAgICAgICAgLy8gU29ydCBieSBJRC4gVGhlIHJlc3VsdGluZyBwYWdlZCBzZXQgaXMgbm90IHBlcmZlY3QsIGFuZCB3aWxsIGhhdmVcbiAgICAgICAgICAgIC8vIGhvbGVzIHdoZW4gbmV3IGVudHJpZXMgYXJlIGFkZGVkIGluIGJldHdlZW4gcXVlcmllcy5cbiAgICAgICAgICAgIG9iamVjdHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgbGV0IGFJZCA9IGEuaWQudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgbGV0IGJJZCA9IGIuaWQudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgcmV0dXJuIChhSWQgPCBiSWQpID8gLTEgOiAoYUlkID4gYklkKSA/IDEgOiAwXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBpZiAoY3Vyc29yID09PSAnJykge1xuICAgICAgICAgICAgICAgLy8gRm9yIGFuIGVtcHR5IGN1cnNvciB3ZSBzdGFydCBmcm9tIHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICAgICAgIGxldCBpdGVtcyA9IG9iamVjdHMuc2xpY2UoMCwgTWF0aC5taW4ob2JqZWN0cy5sZW5ndGgsIGxpbWl0KSlcblxuICAgICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PSBsaW1pdCAmJiBvYmplY3RzLmxlbmd0aCA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHRzLmN1cnNvciA9IEJ1ZmZlci5mcm9tKG9iamVjdHNbbGltaXRdLmlkKS50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gbW9yZSBlbnRyaWVzIGluIHRoZW5leHQgc2V0LCB3ZSBkZWZhdWx0IHRoZSBjdXJzb3JcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5jdXJzb3IgPSAnJ1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICByZXN1bHRzLml0ZW1zID0gaXRlbXNcbiAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBjdXJzb3IgYW5kIGNvbnRpbnVlIGZyb20gd2hlbmNlIHdlIGxlZnQgb2ZmXG4gICAgICAgICAgICAgICBjdXJzb3IgPSBCdWZmZXIuZnJvbShjdXJzb3IsICdiYXNlNjQnKS50b1N0cmluZygnYXNjaWknKVxuXG4gICAgICAgICAgICAgICBsZXQgaW5kZXggPSBvYmplY3RzLmZpbmRJbmRleChvID0+IG8uaWQgPT09IGN1cnNvcilcblxuICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgd2hlbiB0aGUgb2JqZWN0IHRoYXQncyBuZXh0IGhhcyBiZWVuIGRlbGV0ZWRcbiAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBlYXJseVxuICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgIGxldCBuZXh0SW5kZXggPSBpbmRleCArIGxpbWl0XG4gICAgICAgICAgICAgICByZXN1bHRzLml0ZW1zID0gb2JqZWN0cy5zbGljZShpbmRleCwgbmV4dEluZGV4KVxuXG4gICAgICAgICAgICAgICBpZiAob2JqZWN0cy5sZW5ndGggPiBuZXh0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMuY3Vyc29yID0gQnVmZmVyLmZyb20ob2JqZWN0c1tuZXh0SW5kZXhdLmlkKS50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gbW9yZSBlbnRyaWVzIGluIHRoZSBuZXh0IHNldCwgd2UgZGVmYXVsdCB0aGUgY3Vyc29yXG4gICAgICAgICAgICAgICAgICAvLyB0byBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMuY3Vyc29yID0gJydcbiAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgfSlcbiAgICAgICAgIC5jb21taXQoKVxuXG4gICAgICByZXR1cm4gcmVzdWx0c1xuICAgfVxuXG4gICBhc3luYyBkZWxldGVPYmplY3Q8VCBleHRlbmRzIFN0YWNrT2JqZWN0Pihtb2RlbDogSU1vZGVsLCBvYmo6IFQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGF3YWl0IHRoaXMucmZjLmNyZWF0ZShuZXcgRGVsZXRlT2JqZWN0RXZlbnQobW9kZWwsIG9iaikpXG4gICAgICAgICAuZnVsZmlsbChhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlT2JqZWN0KG1vZGVsLCBvYmopXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0YWNrLmVtaXQoRXZlbnRTZXQuT2JqZWN0RGVsZXRlZCwgZXZlbnQpXG4gICAgICAgICB9KVxuICAgICAgICAgLmNvbW1pdCgpXG4gICB9XG5cbiAgIGFzeW5jIGdldE9iamVjdDxUIGV4dGVuZHMgU3RhY2tPYmplY3Q+KG1vZGVsOiBJTW9kZWwsIGlkOiBzdHJpbmcpOiBQcm9taXNlPFQgfCB1bmRlZmluZWQ+IHtcbiAgICAgIGxldCBvYmplY3Q6IFQgfCB1bmRlZmluZWRcblxuICAgICAgYXdhaXQgdGhpcy5yZmMuY3JlYXRlKG5ldyBHZXRPYmplY3RFdmVudChtb2RlbCwgaWQpKVxuICAgICAgICAgLmZ1bGZpbGwoYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgY2FzdCA9IGV2ZW50IGFzIEdldE9iamVjdEV2ZW50PFQ+XG5cbiAgICAgICAgICAgIGlmIChjYXN0Lm9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICBvYmplY3QgPSBjYXN0LmV4aXN0cyA9PT0gRXhpc3RTdGF0ZS5Eb2VzTm90RXhpc3QgP1xuICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuZ2V0T2JqZWN0KG1vZGVsLCBpZClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAvLyBXZSBnZXQgYSBzZXJpYWxpemVkIHZlcnNpb24gb2YgdGhlIE9iamVjdFxuICAgICAgICAgICAgICAgbGV0IHNlcmlhbGl6ZWQgPSBhd2FpdCBQcm94eU9iamVjdC5mcm9tU3RvcmVkKG1vZGVsLCBjYXN0Lm9iamVjdCwgdGhpcy5jb250ZXh0LnNlcmlhbGl6ZXIpXG4gICAgICAgICAgICAgICB0aGlzLmNhY2hlLnNhdmVPYmplY3QobW9kZWwsIHNlcmlhbGl6ZWQpXG5cbiAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgb2JqZWN0ID0gc2VyaWFsaXplZCBhcyBUXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RhY2suZW1pdChFdmVudFNldC5HZXRPYmplY3QsIGV2ZW50KVxuICAgICAgICAgfSlcbiAgICAgICAgIC5jb21taXQoKVxuXG4gICAgICByZXR1cm4gb2JqZWN0XG4gICB9XG5cbiAgIGFzeW5jIGhhc0lkKGlkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgIGxldCBoYXNJZCA9IGZhbHNlXG5cbiAgICAgIGF3YWl0IHRoaXMucmZjLmNyZWF0ZShuZXcgSGFzSWRFdmVudChpZCkpXG4gICAgICAgICAuZnVsZmlsbChhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBjYXN0ID0gZXZlbnQgYXMgSGFzSWRFdmVudFxuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0YWNrLmVtaXQoRXZlbnRTZXQuSGFzSWQsIGV2ZW50KVxuXG4gICAgICAgICAgICBpZiAoY2FzdC5oYXNJZCkge1xuICAgICAgICAgICAgICAgaGFzSWQgPSB0cnVlXG4gICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGFzIGl0IGEgcGx1Z2luIGF0dGVtcHRlZCB0byBzZXQgaXQ/XG4gICAgICAgICAgICBpZiAoY2FzdC5hdHRlbXB0ZWRTZXQpIHtcbiAgICAgICAgICAgICAgIC8vIElmIHNvLCB3ZSBjYW4gdHJ1c3QgdGhhdCBhbiBleHRlcm5hbCBzeXN0ZW0gZG9lc24ndCBoYXZlIGl0XG4gICAgICAgICAgICAgICBoYXNJZCA9IGZhbHNlXG4gICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm8gZXh0ZXJuYWwgc3lzdGVtIGF0dGVtcHRlZCB0byBzZXQgaXQsIGRvIHdlIGhhdmUgaXQgY2FjaGVkP1xuICAgICAgICAgICAgaGFzSWQgPSB0aGlzLmNhY2hlLmhhc0lkKGlkKVxuXG4gICAgICAgICB9KVxuICAgICAgICAgLmNvbW1pdCgpXG5cbiAgICAgIHJldHVybiBoYXNJZFxuICAgfVxuXG4gICBhc3luYyB1cGRhdGVPYmplY3Q8VCBleHRlbmRzIFN0YWNrT2JqZWN0Pihtb2RlbDogSU1vZGVsLCBvYmo6IFQsIG9uVXBkYXRlOiBVcGRhdGVPYmplY3RIYW5kbGVyPFQ+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBhd2FpdCB0aGlzLnJmYy5jcmVhdGUobmV3IFVwZGF0ZU9iamVjdEV2ZW50PFQ+KG1vZGVsLCBvYmopKVxuICAgICAgICAgLmZ1bGZpbGwoYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgY2FzdCA9IGV2ZW50IGFzIFVwZGF0ZU9iamVjdEV2ZW50PFQ+XG5cbiAgICAgICAgICAgIGxldCB1cGRhdGVkID0gY2FzdC51cGRhdGVkXG5cbiAgICAgICAgICAgIGF3YWl0IG9uVXBkYXRlKHVwZGF0ZWQsIGNhc3QuZXhpc3RzKVxuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0YWNrLmVtaXQoRXZlbnRTZXQuT2JqZWN0VXBkYXRlZCwgZXZlbnQpXG4gICAgICAgICB9KVxuICAgICAgICAgLmNvbW1pdCgpXG4gICB9XG59Il19