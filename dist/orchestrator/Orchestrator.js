"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Orchestrator = void 0;
const events_1 = require("../events");
const CommitObjectEvent_1 = require("../events/CommitObjectEvent");
const CreateObjectEvent_1 = require("../events/CreateObjectEvent");
const DeleteObjectEvent_1 = require("../events/DeleteObjectEvent");
const Event_1 = require("../events/Event");
const GetManyObjectsEvent_1 = require("../events/GetManyObjectsEvent");
const HasIdEvent_1 = require("../events/HasIdEvent");
const UpdateObjectEvent_1 = require("../events/UpdateObjectEvent");
class Orchestrator {
    constructor(context) {
        this.context = context;
    }
    get cache() {
        return this.context.cache;
    }
    get rfc() {
        return this.context.rfc;
    }
    get stack() {
        return this.context.stack;
    }
    async commitObject(model, obj) {
        let validations = await model.validate(obj);
        if (!validations.success) {
            throw new Error(`Cannot Save Object with ID ${obj.id} since it fails validation. Reason: ${validations.results.map(r => r.error)}`);
        }
        await this.rfc.create(new CommitObjectEvent_1.CommitObjectEvent(model, obj))
            .fulfill(async (event) => {
            this.cache.saveObject(model, obj);
            await this.stack.emit(Event_1.EventSet.CommitObject, event);
        })
            .commit();
    }
    async createObject(model, obj) {
        await this.rfc.create(new CreateObjectEvent_1.CreateObjectEvent(model, obj))
            .fulfill(async (event) => {
            this.cache.saveObject(model, obj);
            await this.stack.emit(Event_1.EventSet.ObjectCreated, event);
        })
            .commit();
    }
    async getManyObjects(model, options = {}) {
        let results = {
            cursor: '',
            items: new Array()
        };
        await this.rfc.create(new GetManyObjectsEvent_1.GetManyObjectsEvent(model, options))
            .fulfill(async (event) => {
            let cast = event;
            if (cast.results !== undefined) {
                results = cast.results;
                return;
            }
            let objects = this.cache.getObjects(model);
            if (objects.length == 0) {
                return;
            }
            let cursor = options.cursor || '';
            let limit = options.limit || 100;
            // Sort by ID. The resulting paged set is not perfect, and will have
            // holes when new entries are added in between queries.
            objects.sort((a, b) => {
                let aId = a.id.toLowerCase();
                let bId = b.id.toLowerCase();
                return (aId < bId) ? -1 : (aId > bId) ? 1 : 0;
            });
            if (cursor === '') {
                // For an empty cursor we start from the beginning
                let items = objects.slice(0, Math.min(objects.length - 1, limit));
                if (items.length == limit && objects.length > limit) {
                    results.cursor = Buffer.from(objects[limit + 1].id).toString('base64');
                }
                else {
                    // If there are no more entries in thenext set, we default the cursor
                    // to empty string
                    results.cursor = '';
                }
                results.items = items;
                return;
            }
            else {
                // We have a cursor and continue from whence we left off
                cursor = Buffer.from(cursor, 'base64').toString('ascii');
                let index = objects.findIndex(o => o.id === cursor);
                if (index === -1) {
                    // We get here when the object that's next has been deleted
                    // return early
                    return;
                }
                results.items = objects.slice(index, Math.min(objects.length - 1, limit));
                if (results.items.length == limit && objects.length > limit) {
                    results.cursor = Buffer.from(objects[limit + 1].id).toString('base64');
                }
                else {
                    // If there are no more entries in thenext set, we default the cursor
                    // to empty string
                    results.cursor = '';
                }
                return;
            }
            return;
        })
            .commit();
        return results;
    }
    async deleteObject(model, obj) {
        await this.rfc.create(new DeleteObjectEvent_1.DeleteObjectEvent(model, obj))
            .fulfill(async (event) => {
            this.cache.deleteObject(model, obj);
            await this.stack.emit(Event_1.EventSet.ObjectDeleted, event);
        })
            .commit();
    }
    async getObject(model, id) {
        let object;
        await this.rfc.create(new events_1.GetObjectEvent(model, id))
            .fulfill(async (event) => {
            let cast = event;
            if (cast.object === undefined) {
                object = cast.exists === Event_1.ExistState.DoesNotExist ?
                    undefined :
                    this.cache.getObject(model, id);
            }
            else {
                this.cache.saveObject(model, cast.object);
                object = cast.object;
            }
            await this.stack.emit(Event_1.EventSet.GetObject, event);
        })
            .commit();
        return object;
    }
    async hasId(id) {
        let hasId = false;
        await this.rfc.create(new HasIdEvent_1.HasIdEvent(id))
            .fulfill(async (event) => {
            let cast = event;
            if (cast.hasId) {
                hasId = true;
                return;
            }
            // Has it a plugin attempted to set it?
            if (cast.attemptedSet) {
                // If so, we can trust that an external system doesn't have it
                hasId = false;
                return;
            }
            // If no external system attempted to set it, do we have it cached?
            hasId = this.cache.hasId(id);
        })
            .commit();
        return hasId;
    }
    async updateObject(model, obj, onUpdate) {
        await this.rfc.create(new UpdateObjectEvent_1.UpdateObjectEvent(model, obj))
            .fulfill(async (event) => {
            let cast = event;
            let updated = cast.updated;
            await onUpdate(updated, cast.exists);
            await this.stack.emit(Event_1.EventSet.ObjectUpdated, cast);
        })
            .commit();
    }
}
exports.Orchestrator = Orchestrator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT3JjaGVzdHJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL29yY2hlc3RyYXRvci9PcmNoZXN0cmF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEsc0NBQTJDO0FBQzNDLG1FQUFnRTtBQUNoRSxtRUFBZ0U7QUFDaEUsbUVBQWdFO0FBQ2hFLDJDQUF1RDtBQUN2RCx1RUFBb0U7QUFDcEUscURBQWtEO0FBRWxELG1FQUFnRTtBQTBCaEUsTUFBYSxZQUFZO0lBYXRCLFlBQXFCLE9BQXNCO1FBQXRCLFlBQU8sR0FBUCxPQUFPLENBQWU7SUFFM0MsQ0FBQztJQWRELElBQUksS0FBSztRQUNOLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUE7SUFDNUIsQ0FBQztJQUVELElBQUksR0FBRztRQUNKLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUE7SUFDMUIsQ0FBQztJQUVELElBQUksS0FBSztRQUNOLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUE7SUFDNUIsQ0FBQztJQU1ELEtBQUssQ0FBQyxZQUFZLENBQXdCLEtBQWEsRUFBRSxHQUFNO1FBQzVELElBQUksV0FBVyxHQUFHLE1BQU0sS0FBSyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQTtRQUUzQyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRTtZQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixHQUFHLENBQUMsRUFBRSx1Q0FBdUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFBO1NBQ3JJO1FBRUQsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLHFDQUFpQixDQUFJLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQzthQUN2RCxPQUFPLENBQUMsS0FBSyxFQUFFLEtB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S0FBSyxFQUFFLEVBQUU7WUFDdEIsSUFBSSxJQUFJLEdBQUcsS0FBNkIsQ0FBQTtZQUV4QyxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFBO1lBRTFCLE1BQU0sUUFBUSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUE7WUFFcEMsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxnQkFBUSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsQ0FBQTtRQUN0RCxDQUFDLENBQUM7YUFDRCxNQUFNLEVBQUUsQ0FBQTtJQUNmLENBQUM7Q0FDSDtBQWhNRCxvQ0FnTUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdGFja09iamVjdCB9IGZyb20gXCIuLi9Cb25kZWRPYmplY3RcIjtcbmltcG9ydCB7IElDYWNoZSB9IGZyb20gXCIuLi9DYWNoZVwiO1xuaW1wb3J0IHsgR2V0T2JqZWN0RXZlbnQgfSBmcm9tIFwiLi4vZXZlbnRzXCI7XG5pbXBvcnQgeyBDb21taXRPYmplY3RFdmVudCB9IGZyb20gXCIuLi9ldmVudHMvQ29tbWl0T2JqZWN0RXZlbnRcIjtcbmltcG9ydCB7IENyZWF0ZU9iamVjdEV2ZW50IH0gZnJvbSBcIi4uL2V2ZW50cy9DcmVhdGVPYmplY3RFdmVudFwiO1xuaW1wb3J0IHsgRGVsZXRlT2JqZWN0RXZlbnQgfSBmcm9tIFwiLi4vZXZlbnRzL0RlbGV0ZU9iamVjdEV2ZW50XCI7XG5pbXBvcnQgeyBFdmVudFNldCwgRXhpc3RTdGF0ZSB9IGZyb20gXCIuLi9ldmVudHMvRXZlbnRcIjtcbmltcG9ydCB7IEdldE1hbnlPYmplY3RzRXZlbnQgfSBmcm9tIFwiLi4vZXZlbnRzL0dldE1hbnlPYmplY3RzRXZlbnRcIjtcbmltcG9ydCB7IEhhc0lkRXZlbnQgfSBmcm9tIFwiLi4vZXZlbnRzL0hhc0lkRXZlbnRcIjtcbmltcG9ydCB7IElSZXF1ZXN0Rm9yQ2hhbmdlU291cmNlIH0gZnJvbSBcIi4uL2V2ZW50cy9SZXF1ZXN0Rm9yQ2hhbmdlXCI7XG5pbXBvcnQgeyBVcGRhdGVPYmplY3RFdmVudCB9IGZyb20gXCIuLi9ldmVudHMvVXBkYXRlT2JqZWN0RXZlbnRcIjtcbmltcG9ydCB7IElNb2RlbCwgUGFnZVJlcXVlc3QsIFBhZ2VSZXNwb25zZSB9IGZyb20gXCIuLi9Nb2RlbFwiO1xuaW1wb3J0IHsgSVN0YWNrIH0gZnJvbSBcIi4uL3N0YWNrL1N0YWNrXCI7XG5pbXBvcnQgeyBJU3RhY2tDb250ZXh0IH0gZnJvbSBcIi4uL3N0YWNrL1N0YWNrQ29udGV4dFwiO1xuaW1wb3J0IHsgVXBkYXRlT2JqZWN0SGFuZGxlciB9IGZyb20gXCIuLi9zdGFjay9TdGFja1VwZGF0ZVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIElPcmNoZXN0cmF0b3Ige1xuICAgLy8gVE9ETzogQWRkOiBjcmVhdGVNb2RlbCwgZGVsZXRlTW9kZWwgKHRoZXNlIHNob3VsZCBhc3Npc3QgaW4gcnVubmluZyB0ZXN0cylcblxuICAgY29tbWl0T2JqZWN0PFQgZXh0ZW5kcyBTdGFja09iamVjdD4obW9kZWw6IElNb2RlbCwgb2JqOiBUKTogUHJvbWlzZTx2b2lkPlxuICAgY3JlYXRlT2JqZWN0PFQgZXh0ZW5kcyBTdGFja09iamVjdD4obW9kZWw6IElNb2RlbCwgb2JqOiBUKTogUHJvbWlzZTx2b2lkPlxuICAgZGVsZXRlT2JqZWN0PFQgZXh0ZW5kcyBTdGFja09iamVjdD4obW9kZWw6IElNb2RlbCwgb2JqOiBUKTogUHJvbWlzZTx2b2lkPlxuXG4gICAvKipcbiAgICAqIFJldHJpZXZlcyBtYW55IG9iamVjdHMgaW4gYSBwYWdlZCBmYXNoaW9uLlxuICAgICogXG4gICAgKiBAcGFyYW0gbW9kZWwgVGhlIE1vZGVsIHJlcHJlc2VudGluZyB0aGUgT2JqZWN0c1xuICAgICogQHBhcmFtIG9wdGlvbnMgUGFnZVJlcXVlc3QgT3B0aW9uc1xuICAgICovXG4gICBnZXRNYW55T2JqZWN0czxUIGV4dGVuZHMgU3RhY2tPYmplY3Q+KG1vZGVsOiBJTW9kZWwsIG9wdGlvbnM6IFBhZ2VSZXF1ZXN0KTogUHJvbWlzZTxQYWdlUmVzcG9uc2U8VD4+XG4gICBnZXRPYmplY3Q8VCBleHRlbmRzIFN0YWNrT2JqZWN0Pihtb2RlbDogSU1vZGVsLCBpZDogc3RyaW5nKTogUHJvbWlzZTxUIHwgdW5kZWZpbmVkPlxuICAgaGFzSWQoaWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj5cbiAgIHVwZGF0ZU9iamVjdDxUIGV4dGVuZHMgU3RhY2tPYmplY3Q+KG1vZGVsOiBJTW9kZWwsIG9iajogVCwgb25VcGRhdGU6IFVwZGF0ZU9iamVjdEhhbmRsZXI8VD4pOiBQcm9taXNlPHZvaWQ+XG59XG5cblxuZXhwb3J0IGNsYXNzIE9yY2hlc3RyYXRvciBpbXBsZW1lbnRzIElPcmNoZXN0cmF0b3Ige1xuICAgZ2V0IGNhY2hlKCk6IElDYWNoZSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmNhY2hlXG4gICB9XG5cbiAgIGdldCByZmMoKTogSVJlcXVlc3RGb3JDaGFuZ2VTb3VyY2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5yZmNcbiAgIH1cblxuICAgZ2V0IHN0YWNrKCk6IElTdGFjayB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnN0YWNrXG4gICB9XG5cbiAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGNvbnRleHQ6IElTdGFja0NvbnRleHQpIHtcblxuICAgfVxuXG4gICBhc3luYyBjb21taXRPYmplY3Q8VCBleHRlbmRzIFN0YWNrT2JqZWN0Pihtb2RlbDogSU1vZGVsLCBvYmo6IFQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGxldCB2YWxpZGF0aW9ucyA9IGF3YWl0IG1vZGVsLnZhbGlkYXRlKG9iailcblxuICAgICAgaWYgKCF2YWxpZGF0aW9ucy5zdWNjZXNzKSB7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBTYXZlIE9iamVjdCB3aXRoIElEICR7b2JqLmlkfSBzaW5jZSBpdCBmYWlscyB2YWxpZGF0aW9uLiBSZWFzb246ICR7dmFsaWRhdGlvbnMucmVzdWx0cy5tYXAociA9PiByLmVycm9yKX1gKVxuICAgICAgfVxuXG4gICAgICBhd2FpdCB0aGlzLnJmYy5jcmVhdGUobmV3IENvbW1pdE9iamVjdEV2ZW50PFQ+KG1vZGVsLCBvYmopKVxuICAgICAgICAgLmZ1bGZpbGwoYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLnNhdmVPYmplY3QobW9kZWwsIG9iailcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RhY2suZW1pdChFdmVudFNldC5Db21taXRPYmplY3QsIGV2ZW50KVxuICAgICAgICAgfSlcbiAgICAgICAgIC5jb21taXQoKVxuICAgfVxuXG4gICBhc3luYyBjcmVhdGVPYmplY3Q8VCBleHRlbmRzIFN0YWNrT2JqZWN0Pihtb2RlbDogSU1vZGVsLCBvYmo6IFQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGF3YWl0IHRoaXMucmZjLmNyZWF0ZShuZXcgQ3JlYXRlT2JqZWN0RXZlbnQobW9kZWwsIG9iaikpXG4gICAgICAgICAuZnVsZmlsbChhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2F2ZU9iamVjdChtb2RlbCwgb2JqKVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGFjay5lbWl0KEV2ZW50U2V0Lk9iamVjdENyZWF0ZWQsIGV2ZW50KVxuICAgICAgICAgfSlcbiAgICAgICAgIC5jb21taXQoKVxuICAgfVxuXG4gICBhc3luYyBnZXRNYW55T2JqZWN0czxUIGV4dGVuZHMgU3RhY2tPYmplY3Q+KG1vZGVsOiBJTW9kZWwsIG9wdGlvbnM6IFBhZ2VSZXF1ZXN0ID0ge30pOiBQcm9taXNlPFBhZ2VSZXNwb25zZTxUPj4ge1xuICAgICAgbGV0IHJlc3VsdHMgPSB7XG4gICAgICAgICBjdXJzb3I6ICcnLFxuICAgICAgICAgaXRlbXM6IG5ldyBBcnJheTxUPigpXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRoaXMucmZjLmNyZWF0ZShuZXcgR2V0TWFueU9iamVjdHNFdmVudChtb2RlbCwgb3B0aW9ucykpXG4gICAgICAgICAuZnVsZmlsbChhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBjYXN0ID0gZXZlbnQgYXMgR2V0TWFueU9iamVjdHNFdmVudDxUPlxuXG4gICAgICAgICAgICBpZiAoY2FzdC5yZXN1bHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgIHJlc3VsdHMgPSBjYXN0LnJlc3VsdHNcbiAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgb2JqZWN0cyA9IHRoaXMuY2FjaGUuZ2V0T2JqZWN0czxUPihtb2RlbClcblxuICAgICAgICAgICAgaWYgKG9iamVjdHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gb3B0aW9ucy5jdXJzb3IgfHwgJydcbiAgICAgICAgICAgIGxldCBsaW1pdCA9IG9wdGlvbnMubGltaXQgfHwgMTAwXG5cbiAgICAgICAgICAgIC8vIFNvcnQgYnkgSUQuIFRoZSByZXN1bHRpbmcgcGFnZWQgc2V0IGlzIG5vdCBwZXJmZWN0LCBhbmQgd2lsbCBoYXZlXG4gICAgICAgICAgICAvLyBob2xlcyB3aGVuIG5ldyBlbnRyaWVzIGFyZSBhZGRlZCBpbiBiZXR3ZWVuIHF1ZXJpZXMuXG4gICAgICAgICAgICBvYmplY3RzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgIGxldCBhSWQgPSBhLmlkLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgIGxldCBiSWQgPSBiLmlkLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgIHJldHVybiAoYUlkIDwgYklkKSA/IC0xIDogKGFJZCA+IGJJZCkgPyAxIDogMFxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgaWYgKGN1cnNvciA9PT0gJycpIHtcbiAgICAgICAgICAgICAgIC8vIEZvciBhbiBlbXB0eSBjdXJzb3Igd2Ugc3RhcnQgZnJvbSB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAgICAgICBsZXQgaXRlbXMgPSBvYmplY3RzLnNsaWNlKDAsIE1hdGgubWluKG9iamVjdHMubGVuZ3RoIC0gMSwgbGltaXQpKVxuXG4gICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09IGxpbWl0ICYmIG9iamVjdHMubGVuZ3RoID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMuY3Vyc29yID0gQnVmZmVyLmZyb20ob2JqZWN0c1tsaW1pdCArIDFdLmlkKS50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gbW9yZSBlbnRyaWVzIGluIHRoZW5leHQgc2V0LCB3ZSBkZWZhdWx0IHRoZSBjdXJzb3JcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5jdXJzb3IgPSAnJ1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICByZXN1bHRzLml0ZW1zID0gaXRlbXNcbiAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBjdXJzb3IgYW5kIGNvbnRpbnVlIGZyb20gd2hlbmNlIHdlIGxlZnQgb2ZmXG4gICAgICAgICAgICAgICBjdXJzb3IgPSBCdWZmZXIuZnJvbShjdXJzb3IsICdiYXNlNjQnKS50b1N0cmluZygnYXNjaWknKVxuXG4gICAgICAgICAgICAgICBsZXQgaW5kZXggPSBvYmplY3RzLmZpbmRJbmRleChvID0+IG8uaWQgPT09IGN1cnNvcilcblxuICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgd2hlbiB0aGUgb2JqZWN0IHRoYXQncyBuZXh0IGhhcyBiZWVuIGRlbGV0ZWRcbiAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBlYXJseVxuICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgIHJlc3VsdHMuaXRlbXMgPSBvYmplY3RzLnNsaWNlKGluZGV4LCBNYXRoLm1pbihvYmplY3RzLmxlbmd0aCAtIDEsIGxpbWl0KSlcblxuICAgICAgICAgICAgICAgaWYgKHJlc3VsdHMuaXRlbXMubGVuZ3RoID09IGxpbWl0ICYmIG9iamVjdHMubGVuZ3RoID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMuY3Vyc29yID0gQnVmZmVyLmZyb20ob2JqZWN0c1tsaW1pdCArIDFdLmlkKS50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gbW9yZSBlbnRyaWVzIGluIHRoZW5leHQgc2V0LCB3ZSBkZWZhdWx0IHRoZSBjdXJzb3JcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5jdXJzb3IgPSAnJ1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICB9KVxuICAgICAgICAgLmNvbW1pdCgpXG5cbiAgICAgIHJldHVybiByZXN1bHRzXG4gICB9XG5cbiAgIGFzeW5jIGRlbGV0ZU9iamVjdDxUIGV4dGVuZHMgU3RhY2tPYmplY3Q+KG1vZGVsOiBJTW9kZWwsIG9iajogVCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgYXdhaXQgdGhpcy5yZmMuY3JlYXRlKG5ldyBEZWxldGVPYmplY3RFdmVudChtb2RlbCwgb2JqKSlcbiAgICAgICAgIC5mdWxmaWxsKGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5kZWxldGVPYmplY3QobW9kZWwsIG9iailcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RhY2suZW1pdChFdmVudFNldC5PYmplY3REZWxldGVkLCBldmVudClcbiAgICAgICAgIH0pXG4gICAgICAgICAuY29tbWl0KClcbiAgIH1cblxuICAgYXN5bmMgZ2V0T2JqZWN0PFQgZXh0ZW5kcyBTdGFja09iamVjdD4obW9kZWw6IElNb2RlbCwgaWQ6IHN0cmluZyk6IFByb21pc2U8VCB8IHVuZGVmaW5lZD4ge1xuICAgICAgbGV0IG9iamVjdDogVCB8IHVuZGVmaW5lZFxuXG4gICAgICBhd2FpdCB0aGlzLnJmYy5jcmVhdGUobmV3IEdldE9iamVjdEV2ZW50KG1vZGVsLCBpZCkpXG4gICAgICAgICAuZnVsZmlsbChhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBjYXN0ID0gZXZlbnQgYXMgR2V0T2JqZWN0RXZlbnQ8VD5cblxuICAgICAgICAgICAgaWYgKGNhc3Qub2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgIG9iamVjdCA9IGNhc3QuZXhpc3RzID09PSBFeGlzdFN0YXRlLkRvZXNOb3RFeGlzdCA/XG4gICAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5nZXRPYmplY3QobW9kZWwsIGlkKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuc2F2ZU9iamVjdChtb2RlbCwgY2FzdC5vYmplY3QpXG4gICAgICAgICAgICAgICBvYmplY3QgPSBjYXN0Lm9iamVjdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0YWNrLmVtaXQoRXZlbnRTZXQuR2V0T2JqZWN0LCBldmVudClcbiAgICAgICAgIH0pXG4gICAgICAgICAuY29tbWl0KClcblxuICAgICAgcmV0dXJuIG9iamVjdFxuICAgfVxuXG4gICBhc3luYyBoYXNJZChpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICBsZXQgaGFzSWQgPSBmYWxzZVxuXG4gICAgICBhd2FpdCB0aGlzLnJmYy5jcmVhdGUobmV3IEhhc0lkRXZlbnQoaWQpKVxuICAgICAgICAgLmZ1bGZpbGwoYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgY2FzdCA9IGV2ZW50IGFzIEhhc0lkRXZlbnRcblxuICAgICAgICAgICAgaWYgKGNhc3QuaGFzSWQpIHtcbiAgICAgICAgICAgICAgIGhhc0lkID0gdHJ1ZVxuICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhcyBpdCBhIHBsdWdpbiBhdHRlbXB0ZWQgdG8gc2V0IGl0P1xuICAgICAgICAgICAgaWYgKGNhc3QuYXR0ZW1wdGVkU2V0KSB7XG4gICAgICAgICAgICAgICAvLyBJZiBzbywgd2UgY2FuIHRydXN0IHRoYXQgYW4gZXh0ZXJuYWwgc3lzdGVtIGRvZXNuJ3QgaGF2ZSBpdFxuICAgICAgICAgICAgICAgaGFzSWQgPSBmYWxzZVxuICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIG5vIGV4dGVybmFsIHN5c3RlbSBhdHRlbXB0ZWQgdG8gc2V0IGl0LCBkbyB3ZSBoYXZlIGl0IGNhY2hlZD9cbiAgICAgICAgICAgIGhhc0lkID0gdGhpcy5jYWNoZS5oYXNJZChpZClcblxuICAgICAgICAgfSlcbiAgICAgICAgIC5jb21taXQoKVxuXG4gICAgICByZXR1cm4gaGFzSWRcbiAgIH1cblxuICAgYXN5bmMgdXBkYXRlT2JqZWN0PFQgZXh0ZW5kcyBTdGFja09iamVjdD4obW9kZWw6IElNb2RlbCwgb2JqOiBULCBvblVwZGF0ZTogVXBkYXRlT2JqZWN0SGFuZGxlcjxUPik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgYXdhaXQgdGhpcy5yZmMuY3JlYXRlKG5ldyBVcGRhdGVPYmplY3RFdmVudDxUPihtb2RlbCwgb2JqKSlcbiAgICAgICAgIC5mdWxmaWxsKGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNhc3QgPSBldmVudCBhcyBVcGRhdGVPYmplY3RFdmVudDxUPlxuXG4gICAgICAgICAgICBsZXQgdXBkYXRlZCA9IGNhc3QudXBkYXRlZFxuXG4gICAgICAgICAgICBhd2FpdCBvblVwZGF0ZSh1cGRhdGVkLCBjYXN0LmV4aXN0cylcblxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGFjay5lbWl0KEV2ZW50U2V0Lk9iamVjdFVwZGF0ZWQsIGNhc3QpXG4gICAgICAgICB9KVxuICAgICAgICAgLmNvbW1pdCgpXG4gICB9XG59Il19