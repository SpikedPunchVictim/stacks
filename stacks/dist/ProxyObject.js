"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProxyObject = void 0;
const _1 = require(".");
const FieldCollection_1 = require("./collections/FieldCollection");
const Field_1 = require("./Field");
const UidKeeper_1 = require("./UidKeeper");
const ValueSource_1 = require("./values/ValueSource");
let handler = {
    get(target, property) {
        if (property === '_unwrap') {
            // Unwrap the SerializedObject from the Proxy
            return function () {
                return target;
            };
        }
        if (property === 'id') {
            return target.id;
        }
        let field = target.fields.get(property);
        if (field === undefined) {
            // Returning undefined here to not only get around
            // not having the property, but also in the cases
            // when the Proxy is await'd, the underlying system
            // calls then() until an undefiend is returned.
            return undefined;
        }
        return field.edit;
    },
    set(target, property, value) {
        if (property === 'id') {
            let cast = target;
            cast.internaleSetId(value);
        }
        let field = target.fields.get(property);
        if (field === undefined) {
            return false;
        }
        field.edit = value;
        return true;
    }
};
class ProxyObject {
    constructor(model, id, fields) {
        this.model = model;
        this.fields = new FieldCollection_1.FieldCollection(fields);
        this._id = id;
    }
    get id() {
        return this._id;
    }
    static async fromModel(model, context) {
        let fields = new Array();
        for (let member of model.members) {
            let editObj = await context.serializer.toJs(member.value);
            fields.push(new Field_1.Field(member.name, member.value.clone(), editObj));
        }
        let proxy = new ProxyObject(model, UidKeeper_1.UidKeeper.IdNotSet, fields);
        //@ts-ignore
        return new Proxy(proxy, handler);
    }
    static async fromStored(model, serialized, serializer) {
        /*
           Bool -> true
           Int -> 0
           List ->
  
        */
        let fields = new Array();
        for (let key of Object.keys(serialized)) {
            let member = model.members.get(key);
            if (member === undefined) {
                // TODO: Potentially add a version compatibility mode where it doesn't throw an error?
                // May need to support not throwing an Error for migrations
                // Consider turning the IValue objects into little Proxies that can update
                // their own fields.
                throw new Error(`A property exists on ther serialized object, that doesn't exist in the Model. Model ${model.name}, Property ${key}`);
            }
            let value = await serializer.fromJs(member.type, serialized[key]);
            fields.push(new Field_1.Field(key, value, await serializer.toJs(value)));
        }
        let proxy = new ProxyObject(model, serialized.id, fields);
        return new Proxy(proxy, handler);
    }
    static async fromCreated(model, obj, context) {
        let fields = new Array();
        for (let key of Object.keys(obj)) {
            let member = model.members.find(m => m.name === key);
            if (member === undefined) {
                // Ignore keys that don't have matching members
                // Note: This could be a version mismatch between the data
                continue;
            }
            if (member.type.type === _1.TypeSet.ObjectRef) {
                let editObj = await this.buildNestedEditObject(member, obj[key], context);
                let objRefType = member.type;
                let value = context.value.ref(objRefType.modelName);
                fields.push(new Field_1.Field(key, value, editObj));
                continue;
            }
            let value = ValueSource_1.ValueSource.resolve(obj[key], context);
            let jsObj = await context.serializer.toJs(value);
            fields.push(new Field_1.Field(key, value, jsObj));
        }
        for (let member of model.members) {
            if (fields.find(f => f.name === member.name) !== undefined) {
                continue;
            }
            let editObj = await context.serializer.toJs(member.value);
            fields.push(new Field_1.Field(member.name, member.value.clone(), editObj));
        }
        // We create the ID when the Object is stored.
        // This saves round trip time, and covers the case where an 
        // ID may be generated, and not stored in the backend, and
        // another equal ID is generated for a different object.
        //@ts-ignore
        return new Proxy(new ProxyObject(model, UidKeeper_1.UidKeeper.IdNotSet, fields), handler);
    }
    static unwrap(serialized) {
        //@ts-ignore
        return serialized._unwrap();
    }
    static async buildNestedEditObject(member, createValues, context) {
        let objRefType = member.type;
        let refValue = context.value.ref(objRefType.modelName);
        let editObj = await context.serializer.toJs(refValue);
        let model = context.cache.getModel(objRefType.modelName);
        if (model === undefined) {
            throw new Error(`Encountered an error when building an Edit Object. The Model for the nested property ${member.name} does not exist `);
        }
        for (let childKey of Object.keys(createValues)) {
            let childValue = createValues[childKey];
            let childMember = model.members.find(m => m.name === childKey);
            // Ignore values that are provided and we don't have a Member for.
            // This could signal that the data versions are mismatched, and that's ok.
            if (childMember === undefined) {
                continue;
            }
            if (childMember.type.type === _1.TypeSet.ObjectRef) {
                editObj[childKey] = await this.buildNestedEditObject(childMember, childValue, context);
                continue;
            }
            let value = ValueSource_1.ValueSource.resolve(childValue, context);
            editObj[childKey] = await context.serializer.toJs(value);
        }
        return editObj;
    }
    internaleSetId(id) {
        this._id = id;
    }
}
exports.ProxyObject = ProxyObject;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJveHlPYmplY3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvUHJveHlPYmplY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsd0JBQXFDO0FBQ3JDLG1FQUFrRjtBQUNsRixtQ0FBd0M7QUFLeEMsMkNBQXdDO0FBRXhDLHNEQUFzRTtBQW9CdEUsSUFBSSxPQUFPLEdBQUc7SUFDWCxHQUFHLENBQUMsTUFBb0IsRUFBRSxRQUFnQjtRQUN2QyxJQUFHLFFBQVEsS0FBSyxTQUFTLEVBQUU7WUFDeEIsNkNBQTZDO1lBQzdDLE9BQU87Z0JBQ0osT0FBTyxNQUFNLENBQUE7WUFDaEIsQ0FBQyxDQUFBO1NBQ0g7UUFFRCxJQUFHLFFBQVEsS0FBSyxJQUFJLEVBQUU7WUFDbkIsT0FBTyxNQUFNLENBQUMsRUFBRSxDQUFBO1NBQ2xCO1FBRUQsSUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUE7UUFFdkMsSUFBRyxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQ3JCLGtEQUFrRDtZQUNsRCxpREFBaUQ7WUFDakQsbURBQW1EO1lBQ25ELCtDQUErQztZQUMvQyxPQUFPLFNBQVMsQ0FBQTtTQUNsQjtRQUVELE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQTtJQUNwQixDQUFDO0lBQ0QsR0FBRyxDQUFDLE1BQW9CLEVBQUUsUUFBZ0IsRUFBRSxLQUFVO1FBQ25ELElBQUcsUUFBUSxLQUFLLElBQUksRUFBRTtZQUNuQixJQUFJLElBQUksR0FBRyxNQUFxQixDQUFBO1lBQ2hDLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUE7U0FDNUI7UUFFRCxJQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQTtRQUV2QyxJQUFHLEtBQUssS0FBSyxTQUFTLEVBQUU7WUFDckIsT0FBTyxLQUFLLENBQUE7U0FDZDtRQUVELEtBQUssQ0FB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QUFJLFFBQVEsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFO1lBQzVDLElBQUksVUFBVSxHQUFHLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQTtZQUV2QyxJQUFJLFdBQVcsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLENBQUE7WUFFOUQsa0VBQWtFO1lBQ2xFLDBFQUEwRTtZQUMxRSxJQUFHLFdBQVcsS0FBSyxTQUFTLEVBQUU7Z0JBQzNCLFNBQVE7YUFDVjtZQUVELElBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssVUFBTyxDQUFDLFNBQVMsRUFBRTtnQkFDN0MsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLE1BQU0sSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUE7Z0JBQ3RGLFNBQVE7YUFDVjtZQUVELElBQUksS0FBSyxHQUFHLHlCQUFXLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQTtZQUNwRCxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsTUFBTSxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQTtTQUMxRDtRQUVELE9BQU8sT0FBTyxDQUFBO0lBQ2pCLENBQUM7SUFFRCxjQUFjLENBQUMsRUFBVTtRQUN0QixJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQTtJQUNoQixDQUFDO0NBQ0g7QUFoSkQsa0NBZ0pDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSU1lbWJlciwgVHlwZVNldCB9IGZyb20gXCIuXCI7XG5pbXBvcnQgeyBGaWVsZENvbGxlY3Rpb24sIElGaWVsZENvbGxlY3Rpb24gfSBmcm9tIFwiLi9jb2xsZWN0aW9ucy9GaWVsZENvbGxlY3Rpb25cIjtcbmltcG9ydCB7IEZpZWxkLCBJRmllbGQgfSBmcm9tIFwiLi9GaWVsZFwiO1xuaW1wb3J0IHsgSU1vZGVsLCBPYmplY3RDcmVhdGVQYXJhbXMgfSBmcm9tIFwiLi9Nb2RlbFwiO1xuaW1wb3J0IHsgSVZhbHVlU2VyaWFsaXplciB9IGZyb20gXCIuL3NlcmlhbGl6ZS9WYWx1ZVNlcmlhbGl6ZXJcIjtcbmltcG9ydCB7IElTdGFja0NvbnRleHQgfSBmcm9tIFwiLi9zdGFjay9TdGFja0NvbnRleHRcIjtcbmltcG9ydCB7IFN0YWNrT2JqZWN0IH0gZnJvbSBcIi4vU3RhY2tPYmplY3RcIjtcbmltcG9ydCB7IFVpZEtlZXBlciB9IGZyb20gXCIuL1VpZEtlZXBlclwiO1xuaW1wb3J0IHsgT2JqZWN0UmVmVHlwZSB9IGZyb20gXCIuL3ZhbHVlcy9PYmplY3RSZWZcIjtcbmltcG9ydCB7IFZhbHVlQ3JlYXRlUGFyYW1zLCBWYWx1ZVNvdXJjZSB9IGZyb20gXCIuL3ZhbHVlcy9WYWx1ZVNvdXJjZVwiO1xuXG4vKipcbiAqIFRoZSBTZXJpYWxpemVkT2JqZWN0IHN0b3JlcyB0aGUgZGF0YSBiZXR3ZWVuIHRoZSBiYWNrZW5kIGFuZCB0aGUgZnJvbnRlbmQuXG4gKiBJdCBzdG9yZXMgdGhlIG1ldGEgZGF0YSBuZWNlc3NhcnkgdG8gdGllIHRoZSBvYmplY3RzIHVzZWQgb3V0c2lkZSB0aGUgQVBJXG4gKiB0byB0aGVpciBiYWNrZW5kIGNvdW50ZXJwYXJ0cy5cbiAqIFxuICogU2VyaWFsaXplZDogXG4gKiBUaGUgb2JqZWN0IHJlcHJlc2VudGluZyB3aGF0IGlzIHN0b3JlZCBpbiB0aGUgYmFja2VuZFxuICogXG4gKiBEZXNlcmlhbGl6ZWQ6XG4gKiBUaGUgb2JqZWN0IHVzZWQgaW4gdGhlIGZyb250IGVuZC4gVGhlIGZvY3VzIGlzIHRvIHN0YXkgYXMgY2xvc2VcbiAqIHRvIHJhdyBKUyBvYmplY3RzIGFzIHBvc3NpYmxlLiAgIFxuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgSVByb3h5T2JqZWN0IHtcbiAgIHJlYWRvbmx5IGlkOiBzdHJpbmdcbiAgIHJlYWRvbmx5IGZpZWxkczogSUZpZWxkQ29sbGVjdGlvblxufVxuXG5sZXQgaGFuZGxlciA9IHtcbiAgIGdldCh0YXJnZXQ6IElQcm94eU9iamVjdCwgcHJvcGVydHk6IHN0cmluZyk6IGFueSB7XG4gICAgICBpZihwcm9wZXJ0eSA9PT0gJ191bndyYXAnKSB7XG4gICAgICAgICAvLyBVbndyYXAgdGhlIFNlcmlhbGl6ZWRPYmplY3QgZnJvbSB0aGUgUHJveHlcbiAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRcbiAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYocHJvcGVydHkgPT09ICdpZCcpIHtcbiAgICAgICAgIHJldHVybiB0YXJnZXQuaWRcbiAgICAgIH1cblxuICAgICAgbGV0IGZpZWxkID0gdGFyZ2V0LmZpZWxkcy5nZXQocHJvcGVydHkpXG5cbiAgICAgIGlmKGZpZWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIC8vIFJldHVybmluZyB1bmRlZmluZWQgaGVyZSB0byBub3Qgb25seSBnZXQgYXJvdW5kXG4gICAgICAgICAvLyBub3QgaGF2aW5nIHRoZSBwcm9wZXJ0eSwgYnV0IGFsc28gaW4gdGhlIGNhc2VzXG4gICAgICAgICAvLyB3aGVuIHRoZSBQcm94eSBpcyBhd2FpdCdkLCB0aGUgdW5kZXJseWluZyBzeXN0ZW1cbiAgICAgICAgIC8vIGNhbGxzIHRoZW4oKSB1bnRpbCBhbiB1bmRlZmllbmQgaXMgcmV0dXJuZWQuXG4gICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaWVsZC5lZGl0XG4gICB9LFxuICAgc2V0KHRhcmdldDogSVByb3h5T2JqZWN0LCBwcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gICAgICBpZihwcm9wZXJ0eSA9PT0gJ2lkJykge1xuICAgICAgICAgbGV0IGNhc3QgPSB0YXJnZXQgYXMgUHJveHlPYmplY3RcbiAgICAgICAgIGNhc3QuaW50ZXJuYWxlU2V0SWQodmFsdWUpXG4gICAgICB9XG5cbiAgICAgIGxldCBmaWVsZCA9IHRhcmdldC5maWVsZHMuZ2V0KHByb3BlcnR5KVxuXG4gICAgICBpZihmaWVsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgZmllbGQuZWRpdCA9IHZhbHVlXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHJveHlPYmplY3QgaW1wbGVtZW50cyBJUHJveHlPYmplY3Qge1xuICAgcmVhZG9ubHkgZmllbGRzOiBJRmllbGRDb2xsZWN0aW9uXG5cbiAgIGdldCBpZCgpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIHRoaXMuX2lkXG4gICB9XG5cbiAgIHByaXZhdGUgX2lkOiBzdHJpbmdcblxuICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihyZWFkb25seSBtb2RlbDogSU1vZGVsLCBpZDogc3RyaW5nLCBmaWVsZHM6IElGaWVsZFtdKSB7XG4gICAgICB0aGlzLmZpZWxkcyA9IG5ldyBGaWVsZENvbGxlY3Rpb24oZmllbGRzKVxuICAgICAgdGhpcy5faWQgPSBpZFxuICAgfVxuXG4gICBzdGF0aWMgYXN5bmMgZnJvbU1vZGVsPFQgZXh0ZW5kcyBTdGFja09iamVjdD4obW9kZWw6IElNb2RlbCwgY29udGV4dDogSVN0YWNrQ29udGV4dCk6IFByb21pc2U8VD4ge1xuICAgICAgbGV0IGZpZWxkcyA9IG5ldyBBcnJheTxJRmllbGQ+KClcblxuICAgICAgZm9yIChsZXQgbWVtYmVyIG9mIG1vZGVsLm1lbWJlcnMpIHtcbiAgICAgICAgIGxldCBlZGl0T2JqID0gYXdhaXQgY29udGV4dC5zZXJpYWxpemVyLnRvSnMobWVtYmVyLnZhbHVlKVxuICAgICAgICAgZmllbGRzLnB1c2gobmV3IEZpZWxkKG1lbWJlci5uYW1lLCBtZW1iZXIudmFsdWUuY2xvbmUoKSwgZWRpdE9iaikpXG4gICAgICB9XG5cbiAgICAgIGxldCBwcm94eSA9IG5ldyBQcm94eU9iamVjdChtb2RlbCwgVWlkS2VlcGVyLklkTm90U2V0LCBmaWVsZHMpXG5cbiAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgcmV0dXJuIG5ldyBQcm94eTxJUHJveHlPYmplY3Q+KHByb3h5LCBoYW5kbGVyKVxuICAgfVxuXG4gICBzdGF0aWMgYXN5bmMgZnJvbVN0b3JlZChtb2RlbDogSU1vZGVsLCBzZXJpYWxpemVkOiBhbnksIHNlcmlhbGl6ZXI6IElWYWx1ZVNlcmlhbGl6ZXIpOiBQcm9taXNlPElQcm94eU9iamVjdD4ge1xuICAgICAgLypcbiAgICAgICAgIEJvb2wgLT4gdHJ1ZVxuICAgICAgICAgSW50IC0+IDBcbiAgICAgICAgIExpc3QgLT5cblxuICAgICAgKi9cblxuICAgICAgbGV0IGZpZWxkcyA9IG5ldyBBcnJheTxJRmllbGQ+KClcblxuICAgICAgZm9yKGxldCBrZXkgb2YgT2JqZWN0LmtleXMoc2VyaWFsaXplZCkpIHtcbiAgICAgICAgIGxldCBtZW1iZXIgPSBtb2RlbC5tZW1iZXJzLmdldChrZXkpXG5cbiAgICAgICAgIGlmKG1lbWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBQb3RlbnRpYWxseSBhZGQgYSB2ZXJzaW9uIGNvbXBhdGliaWxpdHkgbW9kZSB3aGVyZSBpdCBkb2Vzbid0IHRocm93IGFuIGVycm9yP1xuICAgICAgICAgICAgLy8gTWF5IG5lZWQgdG8gc3VwcG9ydCBub3QgdGhyb3dpbmcgYW4gRXJyb3IgZm9yIG1pZ3JhdGlvbnNcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIHR1cm5pbmcgdGhlIElWYWx1ZSBvYmplY3RzIGludG8gbGl0dGxlIFByb3hpZXMgdGhhdCBjYW4gdXBkYXRlXG4gICAgICAgICAgICAvLyB0aGVpciBvd24gZmllbGRzLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIHByb3BlcnR5IGV4aXN0cyBvbiB0aGVyIHNlcmlhbGl6ZWQgb2JqZWN0LCB0aGF0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIE1vZGVsLiBNb2RlbCAke21vZGVsLm5hbWV9LCBQcm9wZXJ0eSAke2tleX1gKVxuICAgICAgICAgfVxuXG4gICAgICAgICBsZXQgdmFsdWUgPSBhd2FpdCBzZXJpYWxpemVyLmZyb21KcyhtZW1iZXIudHlwZSwgc2VyaWFsaXplZFtrZXldKVxuXG4gICAgICAgICBmaWVsZHMucHVzaChuZXcgRmllbGQoa2V5LCB2YWx1ZSwgYXdhaXQgc2VyaWFsaXplci50b0pzKHZhbHVlKSkpXG4gICAgICB9XG5cbiAgICAgIGxldCBwcm94eSA9IG5ldyBQcm94eU9iamVjdChtb2RlbCwgc2VyaWFsaXplZC5pZCwgZmllbGRzKVxuICAgICAgcmV0dXJuIG5ldyBQcm94eTxJUHJveHlPYmplY3Q+KHByb3h5LCBoYW5kbGVyKVxuICAgfVxuXG4gICBzdGF0aWMgYXN5bmMgZnJvbUNyZWF0ZWQ8VCBleHRlbmRzIFN0YWNrT2JqZWN0Pihtb2RlbDogSU1vZGVsLCBvYmo6IE9iamVjdENyZWF0ZVBhcmFtcywgY29udGV4dDogSVN0YWNrQ29udGV4dCk6IFByb21pc2U8VD4ge1xuICAgICAgbGV0IGZpZWxkcyA9IG5ldyBBcnJheTxJRmllbGQ+KClcblxuICAgICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgIGxldCBtZW1iZXIgPSBtb2RlbC5tZW1iZXJzLmZpbmQobSA9PiBtLm5hbWUgPT09IGtleSlcblxuICAgICAgICAgaWYobWVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBrZXlzIHRoYXQgZG9uJ3QgaGF2ZSBtYXRjaGluZyBtZW1iZXJzXG4gICAgICAgICAgICAvLyBOb3RlOiBUaGlzIGNvdWxkIGJlIGEgdmVyc2lvbiBtaXNtYXRjaCBiZXR3ZWVuIHRoZSBkYXRhXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgfVxuXG4gICAgICAgICBpZihtZW1iZXIudHlwZS50eXBlID09PSBUeXBlU2V0Lk9iamVjdFJlZikge1xuICAgICAgICAgICAgbGV0IGVkaXRPYmogPSBhd2FpdCB0aGlzLmJ1aWxkTmVzdGVkRWRpdE9iamVjdChtZW1iZXIsIG9ialtrZXldLCBjb250ZXh0KVxuICAgICAgICAgICAgbGV0IG9ialJlZlR5cGUgPSBtZW1iZXIudHlwZSBhcyBPYmplY3RSZWZUeXBlXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjb250ZXh0LnZhbHVlLnJlZihvYmpSZWZUeXBlLm1vZGVsTmFtZSlcblxuICAgICAgICAgICAgZmllbGRzLnB1c2gobmV3IEZpZWxkKGtleSwgdmFsdWUsIGVkaXRPYmopKVxuXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgfVxuXG4gICAgICAgICBsZXQgdmFsdWUgPSBWYWx1ZVNvdXJjZS5yZXNvbHZlKG9ialtrZXldIGFzIFZhbHVlQ3JlYXRlUGFyYW1zLCBjb250ZXh0KVxuICAgICAgICAgbGV0IGpzT2JqID0gYXdhaXQgY29udGV4dC5zZXJpYWxpemVyLnRvSnModmFsdWUpXG4gICAgICAgICBmaWVsZHMucHVzaChuZXcgRmllbGQoa2V5LCB2YWx1ZSwganNPYmopKVxuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBtZW1iZXIgb2YgbW9kZWwubWVtYmVycykge1xuICAgICAgICAgaWYgKGZpZWxkcy5maW5kKGYgPT4gZi5uYW1lID09PSBtZW1iZXIubmFtZSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgIH1cblxuICAgICAgICAgbGV0IGVkaXRPYmogPSBhd2FpdCBjb250ZXh0LnNlcmlhbGl6ZXIudG9KcyhtZW1iZXIudmFsdWUpXG5cbiAgICAgICAgIGZpZWxkcy5wdXNoKG5ldyBGaWVsZChtZW1iZXIubmFtZSwgbWVtYmVyLnZhbHVlLmNsb25lKCksIGVkaXRPYmopKVxuICAgICAgfVxuXG4gICAgICAvLyBXZSBjcmVhdGUgdGhlIElEIHdoZW4gdGhlIE9iamVjdCBpcyBzdG9yZWQuXG4gICAgICAvLyBUaGlzIHNhdmVzIHJvdW5kIHRyaXAgdGltZSwgYW5kIGNvdmVycyB0aGUgY2FzZSB3aGVyZSBhbiBcbiAgICAgIC8vIElEIG1heSBiZSBnZW5lcmF0ZWQsIGFuZCBub3Qgc3RvcmVkIGluIHRoZSBiYWNrZW5kLCBhbmRcbiAgICAgIC8vIGFub3RoZXIgZXF1YWwgSUQgaXMgZ2VuZXJhdGVkIGZvciBhIGRpZmZlcmVudCBvYmplY3QuXG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIHJldHVybiBuZXcgUHJveHk8SVByb3h5T2JqZWN0PihuZXcgUHJveHlPYmplY3QobW9kZWwsIFVpZEtlZXBlci5JZE5vdFNldCwgZmllbGRzKSwgaGFuZGxlcikgYXMgVFxuICAgfVxuXG4gICBzdGF0aWMgdW53cmFwKHNlcmlhbGl6ZWQ6IElQcm94eU9iamVjdCk6IElQcm94eU9iamVjdCB7XG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIHJldHVybiBzZXJpYWxpemVkLl91bndyYXAoKVxuICAgfVxuXG4gICBwcml2YXRlIHN0YXRpYyBhc3luYyBidWlsZE5lc3RlZEVkaXRPYmplY3QobWVtYmVyOiBJTWVtYmVyLCBjcmVhdGVWYWx1ZXM6IFZhbHVlQ3JlYXRlUGFyYW1zIHwgT2JqZWN0Q3JlYXRlUGFyYW1zLCBjb250ZXh0OiBJU3RhY2tDb250ZXh0KTogUHJvbWlzZTxhbnk+IHtcbiAgICAgIGxldCBvYmpSZWZUeXBlID0gbWVtYmVyLnR5cGUgYXMgT2JqZWN0UmVmVHlwZVxuICAgICAgbGV0IHJlZlZhbHVlID0gY29udGV4dC52YWx1ZS5yZWYob2JqUmVmVHlwZS5tb2RlbE5hbWUpXG4gICAgICBsZXQgZWRpdE9iaiA9IGF3YWl0IGNvbnRleHQuc2VyaWFsaXplci50b0pzKHJlZlZhbHVlKVxuICAgICAgbGV0IG1vZGVsID0gY29udGV4dC5jYWNoZS5nZXRNb2RlbChvYmpSZWZUeXBlLm1vZGVsTmFtZSlcblxuICAgICAgaWYobW9kZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbmNvdW50ZXJlZCBhbiBlcnJvciB3aGVuIGJ1aWxkaW5nIGFuIEVkaXQgT2JqZWN0LiBUaGUgTW9kZWwgZm9yIHRoZSBuZXN0ZWQgcHJvcGVydHkgJHttZW1iZXIubmFtZX0gZG9lcyBub3QgZXhpc3QgYClcbiAgICAgIH1cblxuICAgICAgZm9yKGxldCBjaGlsZEtleSBvZiBPYmplY3Qua2V5cyhjcmVhdGVWYWx1ZXMpKSB7XG4gICAgICAgICBsZXQgY2hpbGRWYWx1ZSA9IGNyZWF0ZVZhbHVlc1tjaGlsZEtleV1cblxuICAgICAgICAgbGV0IGNoaWxkTWVtYmVyID0gbW9kZWwubWVtYmVycy5maW5kKG0gPT4gbS5uYW1lID09PSBjaGlsZEtleSlcblxuICAgICAgICAgLy8gSWdub3JlIHZhbHVlcyB0aGF0IGFyZSBwcm92aWRlZCBhbmQgd2UgZG9uJ3QgaGF2ZSBhIE1lbWJlciBmb3IuXG4gICAgICAgICAvLyBUaGlzIGNvdWxkIHNpZ25hbCB0aGF0IHRoZSBkYXRhIHZlcnNpb25zIGFyZSBtaXNtYXRjaGVkLCBhbmQgdGhhdCdzIG9rLlxuICAgICAgICAgaWYoY2hpbGRNZW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYoY2hpbGRNZW1iZXIudHlwZS50eXBlID09PSBUeXBlU2V0Lk9iamVjdFJlZikge1xuICAgICAgICAgICAgZWRpdE9ialtjaGlsZEtleV0gPSBhd2FpdCB0aGlzLmJ1aWxkTmVzdGVkRWRpdE9iamVjdChjaGlsZE1lbWJlciwgY2hpbGRWYWx1ZSwgY29udGV4dClcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICB9XG5cbiAgICAgICAgIGxldCB2YWx1ZSA9IFZhbHVlU291cmNlLnJlc29sdmUoY2hpbGRWYWx1ZSwgY29udGV4dClcbiAgICAgICAgIGVkaXRPYmpbY2hpbGRLZXldID0gYXdhaXQgY29udGV4dC5zZXJpYWxpemVyLnRvSnModmFsdWUpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlZGl0T2JqXG4gICB9XG5cbiAgIGludGVybmFsZVNldElkKGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIHRoaXMuX2lkID0gaWRcbiAgIH1cbn0iXX0=