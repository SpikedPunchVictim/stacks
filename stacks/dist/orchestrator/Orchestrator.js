"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Orchestrator = void 0;
const Model_1 = require("../Model");
const ProxyObject_1 = require("../ProxyObject");
const UidKeeper_1 = require("../UidKeeper");
const events_1 = require("../events");
class Orchestrator {
    constructor(context) {
        this.context = context;
    }
    get cache() {
        return this.context.cache;
    }
    get rfc() {
        return this.context.rfc;
    }
    get serializer() {
        return this.context.serializer;
    }
    get stack() {
        return this.context.stack;
    }
    get uid() {
        return this.context.uid;
    }
    async boostrap() {
        await this.rfc.create(new events_1.BootstrapEvent())
            .fulfill(async (event) => {
            await this.stack.emit(events_1.EventSet.Bootstrap, event);
        })
            .commit();
    }
    async createModel(name, params) {
        let model = await this.stack.get.model(name);
        if (model !== undefined) {
            throw new Error(`A Model with the name ${name} already exists`);
        }
        model = await Model_1.Model.create(name, this.context);
        await model.append(params);
        this.cache.saveModel(model);
        await this.rfc.create(new events_1.ModelCreateEvent(model))
            .fulfill(async (event) => {
            await this.stack.emit(events_1.EventSet.ModelCreated, event);
        })
            .commit();
        return model;
    }
    async deleteModel(model) {
        await this.rfc.create(new events_1.ModelDeleteEvent(model))
            .fulfill(async (event) => {
            this.cache.deleteModel(model.name);
        })
            .commit();
    }
    // Note: This may not be needed. Watch for this.
    // Model's are stored in local cache because they are
    // defined locally, and are the contract between the
    // the expected data set and what is stored.
    async getModel(name) {
        let model;
        await this.rfc.create(new events_1.GetModelEvent(name))
            .fulfill(async (event) => {
            let getModel = event;
            model = getModel.model || this.cache.getModel(name);
            if (model !== undefined) {
                this.cache.saveModel(model);
            }
            await this.stack.emit(events_1.EventSet.GetModel, event);
        })
            .commit();
        return model;
    }
    async updateModel(model, params) {
        this.rfc.create(new events_1.ModelUpdateEvent(model))
            .fulfill(async (event) => {
            let updateModelEvent = event;
            this.cache.saveModel(updateModelEvent.model);
        })
            .commit();
    }
    async createObject(model, params) {
        let created = await ProxyObject_1.ProxyObject.fromCreated(model, params, this.context);
        await this.rfc.create(new events_1.ObjectCreateEvent(model, created))
            .fulfill(async (event) => {
            await this.stack.emit(events_1.EventSet.ObjectCreated, event);
        })
            .commit();
        return created;
    }
    /**
     *
     * @param model The Model
     * @param obj The Object to save. Note that this is really a Proxy'd SerializableObject
     */
    async saveObject(model, obj) {
        if (obj.id === UidKeeper_1.UidKeeper.IdNotSet) {
            obj.id = await this.uid.generate(model);
        }
        let validations = await model.validate(obj);
        if (!validations.success) {
            throw new Error(`Cannot Save Object with ID ${obj.id} since it fails validation. Reason: ${validations.results.map(r => r.error)}`);
        }
        //@ts-ignore
        let serialized = ProxyObject_1.ProxyObject.unwrap(obj);
        await this.rfc.create(new events_1.ObjectSaveEvent(model, obj, serialized))
            .fulfill(async (event) => {
            this.cache.saveObject(model, obj);
            await this.stack.emit(events_1.EventSet.ObjectSaved, event);
        })
            .commit();
    }
    async getManyObjects(model, options = { cursor: '', limit: 100 }) {
        let results = {
            cursor: '',
            items: new Array()
        };
        await this.rfc.create(new events_1.GetManyObjectsEvent(model, options))
            .fulfill(async (event) => {
            let cast = event;
            await this.stack.emit(events_1.EventSet.GetManyObjects, cast);
            if (cast.results !== undefined) {
                results = cast.results;
                return;
            }
            let objects = this.cache.getObjects(model);
            if (objects.length == 0) {
                return;
            }
            let cursor = options.cursor || '';
            let limit = options.limit || 100;
            // Sort by ID. The resulting paged set is not perfect, and will have
            // holes when new entries are added in between queries.
            objects.sort((a, b) => {
                let aId = a.id.toLowerCase();
                let bId = b.id.toLowerCase();
                return (aId < bId) ? -1 : (aId > bId) ? 1 : 0;
            });
            if (cursor === '') {
                // For an empty cursor we start from the beginning
                let items = objects.slice(0, Math.min(objects.length, limit));
                if (items.length == limit && objects.length > limit) {
                    results.cursor = Buffer.from(objects[limit].id).toString('base64');
                }
                else {
                    // If there are no more entries in thenext set, we default the cursor
                    // to empty string
                    results.cursor = '';
                }
                results.items = items;
                return;
            }
            else {
                // We have a cursor and continue from whence we left off
                cursor = Buffer.from(cursor, 'base64').toString('ascii');
                let index = objects.findIndex(o => o.id === cursor);
                if (index === -1) {
                    // We get here when the object that's next has been deleted
                    // return early
                    return;
                }
                let nextIndex = index + limit;
                results.items = objects.slice(index, nextIndex);
                if (objects.length > nextIndex) {
                    results.cursor = Buffer.from(objects[nextIndex].id).toString('base64');
                }
                else {
                    // If there are no more entries in the next set, we default the cursor
                    // to empty string
                    results.cursor = '';
                }
                return;
            }
            return;
        })
            .commit();
        return results;
    }
    async deleteObject(model, obj) {
        await this.rfc.create(new events_1.ObjectDeleteEvent(model, obj))
            .fulfill(async (event) => {
            this.cache.deleteObject(model, obj);
            await this.stack.emit(events_1.EventSet.ObjectDeleted, event);
        })
            .commit();
    }
    async getObject(model, id) {
        let object;
        await this.rfc.create(new events_1.GetObjectEvent(model, id))
            .fulfill(async (event) => {
            let cast = event;
            if (cast.object === undefined) {
                object = cast.exists === events_1.ExistState.DoesNotExist ?
                    undefined :
                    this.cache.getObject(model, id);
            }
            else {
                // We get a serialized version of the Object
                let serialized = await ProxyObject_1.ProxyObject.fromStored(model, cast.object, this.context.serializer);
                this.cache.saveObject(model, serialized);
                //@ts-ignore
                object = serialized;
            }
            await this.stack.emit(events_1.EventSet.GetObject, event);
        })
            .commit();
        return object;
    }
    async hasId(id, model) {
        let hasId = false;
        await this.rfc.create(new events_1.HasIdEvent(id, model))
            .fulfill(async (event) => {
            let cast = event;
            await this.stack.emit(events_1.EventSet.HasId, event);
            if (cast.hasId) {
                hasId = true;
                return;
            }
            // Has it a plugin attempted to set it?
            if (cast.attemptedSet) {
                // If so, we can trust that an external system doesn't have it
                hasId = false;
                return;
            }
            // If no external system attempted to set it, do we have it cached?
            hasId = this.cache.hasId(id);
        })
            .commit();
        return hasId;
    }
    async storeQueryObject(handler) {
        let result = undefined;
        await this.rfc.create(new events_1.GetStoreContextEvent())
            .fulfill(async (event) => {
            let getStoreContext = event;
            result = await handler(getStoreContext.contexts);
        })
            .commit();
        return result;
    }
    /**
     * Updates an already existing object with the latest from the stored version.
     * This method is intended to be used on long lived objects where we want them
     * to be updated locally, and not saved.
     *
     * @param model The Model
     * @param obj The Object
     * @param onUpdate Function to update the Object based on the latest version
     */
    async updateObject(model, obj, onUpdate) {
        await this.rfc.create(new events_1.ObjectUpdateEvent(model, obj, ProxyObject_1.ProxyObject.unwrap(obj)))
            .fulfill(async (event) => {
            let cast = event;
            let updated = cast.updated;
            await onUpdate(updated, cast.exists);
            await this.stack.emit(events_1.EventSet.ObjectUpdated, event);
        })
            .commit();
    }
}
exports.Orchestrator = Orchestrator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT3JjaGVzdHJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL29yY2hlc3RyYXRvci9PcmNoZXN0cmF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEsb0NBQTJHO0FBSTNHLGdEQUE2QztBQUM3Qyw0Q0FBcUQ7QUFHckQsc0NBaUJrQjtBQTRHbEIsTUFBYSxZQUFZO0lBcUJ0QixZQUFxQixPQUFzQjtRQUF0QixZQUFPLEdBQVAsT0FBTyxDQUFlO0lBRTNDLENBQUM7SUF0QkQsSUFBSSxLQUFLO1FBQ04sT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQTtJQUM1QixDQUFDO0lBRUQsSUFBSSxHQUFHO1FBQ0osT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQTtJQUMxQixDQUFDO0lBRUQsSUFBSSxVQUFVO1FBQ1gsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQTtJQUNqQyxDQUFDO0lBRUQsSUFBSSxLQUFLO1FBQ04sT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQTtJQUM1QixDQUFDO0lBRUQsSUFBSSxHQUFHO1FBQ0osT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQTtJQUMxQixDQUFDO0lBTUQsS0FBSyxDQUFDLFFBQVE7UUFDWCxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksdUJBQWMsRUFBRSxDQUFDO2FBQ3ZDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFDdEIsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxpQkFBUSxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQTtRQUNuRCxDQUFDLENBQUM7YUFDRCxNQUFNLEVBQUUsQ0FBQTtJQUNmLENBQUM7SUFFRCxLQUFLLENBQUMsV0FBVyxDQUFDLElBQVksRUFBRSxNQUF5QjtRQUN0RCxJQUFJLEtBQUssR0FBRyxNQUFN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RCxDQUFDLENBQUM7YUFDRCxNQUFNLEVBQUUsQ0FBQTtRQUVaLE9BQU8sTUFBTSxDQUFBO0lBQ2hCLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNILEtBQUssQ0FBQyxZQUFZLENBQXdCLEtBQWEsRUFBRSxHQUFNLEVBQUUsUUFBZ0M7UUFDOUYsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLDBCQUFpQixDQUFJLEtBQUssRUFBRSxHQUFHLEVBQUUseUJBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzthQUNoRixPQUFPLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQ3RCLElBQUksSUFBSSxHQUFHLEtBQTZCLENBQUE7WUFFeEMsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQTtZQUUxQixNQUFNLFFBQVEsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO1lBRXBDLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsaUJBQVEsQ0FBQyxhQUFhLEVBQUUsS0FBSyxDQUFDLENBQUE7UUFDdkQsQ0FBQyxDQUFDO2FBQ0QsTUFBTSxFQUFFLENBQUE7SUFDZixDQUFDO0NBQ0g7QUE1VEQsb0NBNFRDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3RhY2tPYmplY3QgfSBmcm9tIFwiLi4vU3RhY2tPYmplY3RcIjtcbmltcG9ydCB7IElDYWNoZSB9IGZyb20gXCIuLi9DYWNoZVwiO1xuaW1wb3J0IHsgSU1vZGVsLCBNb2RlbCwgTW9kZWxDcmVhdGVQYXJhbXMsIE9iamVjdENyZWF0ZVBhcmFtcywgUGFnZVJlcXVlc3QsIFBhZ2VSZXNwb25zZSB9IGZyb20gXCIuLi9Nb2RlbFwiO1xuaW1wb3J0IHsgQXBwbHlTdG9yZUNvbnRleHRIYW5kbGVyLCBJU3RhY2sgfSBmcm9tIFwiLi4vc3RhY2svU3RhY2tcIjtcbmltcG9ydCB7IElTdGFja0NvbnRleHQgfSBmcm9tIFwiLi4vc3RhY2svU3RhY2tDb250ZXh0XCI7XG5pbXBvcnQgeyBVcGRhdGVPYmplY3RIYW5kbGVyIH0gZnJvbSBcIi4uL3N0YWNrL1N0YWNrVXBkYXRlXCI7XG5pbXBvcnQgeyBQcm94eU9iamVjdCB9IGZyb20gXCIuLi9Qcm94eU9iamVjdFwiO1xuaW1wb3J0IHsgSVVpZEtlZXBlciwgVWlkS2VlcGVyIH0gZnJvbSBcIi4uL1VpZEtlZXBlclwiO1xuaW1wb3J0IHsgSVZhbHVlU2VyaWFsaXplciB9IGZyb20gXCIuLi9zZXJpYWxpemUvVmFsdWVTZXJpYWxpemVyXCI7XG5cbmltcG9ydCB7XG4gICBCb290c3RyYXBFdmVudCxcbiAgIE1vZGVsQ3JlYXRlRXZlbnQsXG4gICBPYmplY3RDcmVhdGVFdmVudCxcbiAgIE1vZGVsRGVsZXRlRXZlbnQsXG4gICBPYmplY3REZWxldGVFdmVudCxcbiAgIEV2ZW50U2V0LFxuICAgRXhpc3RTdGF0ZSxcbiAgIEdldE1hbnlPYmplY3RzRXZlbnQsXG4gICBHZXRNb2RlbEV2ZW50LFxuICAgR2V0T2JqZWN0RXZlbnQsXG4gICBHZXRTdG9yZUNvbnRleHRFdmVudCxcbiAgIEhhc0lkRXZlbnQsXG4gICBJUmVxdWVzdEZvckNoYW5nZVNvdXJjZSxcbiAgIE9iamVjdFNhdmVFdmVudCxcbiAgIE9iamVjdFVwZGF0ZUV2ZW50LFxuICAgTW9kZWxVcGRhdGVFdmVudFxufSBmcm9tICcuLi9ldmVudHMnXG5leHBvcnQgaW50ZXJmYWNlIElPcmNoZXN0cmF0b3Ige1xuICAgLy8gVE9ETzogQWRkOiBjcmVhdGVNb2RlbCwgZGVsZXRlTW9kZWwgKHRoZXNlIHNob3VsZCBhc3Npc3QgaW4gcnVubmluZyB0ZXN0cylcblxuICAgLyoqXG4gICAgKiBCb290c3RyYXBzIHRoZSBTdGFjay5cbiAgICAqL1xuICAgYm9vc3RyYXAoKTogUHJvbWlzZTx2b2lkPlxuXG4gICAvKipcbiAgICAqIENyZWF0ZXMgYSBNb2RlbFxuICAgICogXG4gICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgTW9kZWxcbiAgICAqIEBwYXJhbSBwYXJhbXMgVGhlIFBhcmFtcyB1c2VkIHRvIGNyZWF0ZSB0aGUgTW9kZWxcbiAgICAqL1xuICAgY3JlYXRlTW9kZWwobmFtZTogc3RyaW5nLCBwYXJhbXM6IE1vZGVsQ3JlYXRlUGFyYW1zKTogUHJvbWlzZTxJTW9kZWw+XG5cbiAgIC8qKlxuICAgICogRGVsZXRlcyBhIE1vZGVsXG4gICAgKiBcbiAgICAqIEBwYXJhbSBtb2RlbCBUaGUgTW9kZWwgdG8gZGVsZXRlXG4gICAgKi9cbiAgIGRlbGV0ZU1vZGVsKG1vZGVsOiBJTW9kZWwpOiBQcm9taXNlPHZvaWQ+XG5cbiAgIC8qKlxuICAgICogUmV0cmlldmVzIGEgTW9kZWwgaWYgaXQgZXhpc3RzLCBvciB1bmRlZmllbmQgaWYgbm90LlxuICAgICogXG4gICAgKiBAcGFyYW0gbmFtZSBUaGUgTW9kZWwgbmFtZVxuICAgICovXG4gICBnZXRNb2RlbChuYW1lOiBzdHJpbmcpOiBQcm9taXNlPElNb2RlbCB8IHVuZGVmaW5lZD5cblxuICAgLyoqXG4gICAgKiBVcGRhdGVzIGFuIGV4aXN0aW5nIE1vZGVsXG4gICAgKiBcbiAgICAqIEBwYXJhbSBtb2RlbCBUaGUgTW9kZWwgdG8gdXBkYXRlXG4gICAgKiBAcGFyYW0gcGFyYW1zIFRoZSBQYXJhbXNcbiAgICAqL1xuICAgdXBkYXRlTW9kZWwobW9kZWw6IElNb2RlbCwgcGFyYW1zOiBNb2RlbENyZWF0ZVBhcmFtcyk6IFByb21pc2U8dm9pZD5cblxuICAgLyoqXG4gICAgKiBDcmVhdGVzIGEgbmV3IE9iamVjdCBpbiBtZW1vcnkgb25seS4gTm90IGluZGVuZGVkIHRvIGJlIHN0b3JlZCBvbiB0aGUgYmFja2VuZC5cbiAgICAqIE9iamVjdHMgY3JlYXRlZCB0aGlzIHdheSBoYXZlIG5vIElEIGFzc2lnbmVkIHRvIHRoZW0gdW50aWwgdGhleSBhcmUgc2F2ZWQuXG4gICAgKiBcbiAgICAqIEBwYXJhbSBtb2RlbCBUaGUgTW9kZWxcbiAgICAqIEBwYXJhbSBwYXJhbXMgVGhlIE9iamVjdCBDcmVhdGlvbiBQYXJhbXMgXG4gICAgKi9cbiAgIGNyZWF0ZU9iamVjdDxUIGV4dGVuZHMgU3RhY2tPYmplY3Q+KG1vZGVsOiBJTW9kZWwsIHBhcmFtczogT2JqZWN0Q3JlYXRlUGFyYW1zKTogUHJvbWlzZTxUPlxuXG4gICAvKipcbiAgICAqIFNhdmVzIGFuIE9iamVjdCB0byB0aGUgYmFja2VuZC5cbiAgICAqIFxuICAgICogQHBhcmFtIG1vZGVsIFRoZSBNb2RlbFxuICAgICogQHBhcmFtIG9iaiBUaGUgT2JqZWN0IHRvIFNhdmVcbiAgICAqL1xuICAgc2F2ZU9iamVjdDxUIGV4dGVuZHMgU3RhY2tPYmplY3Q+KG1vZGVsOiBJTW9kZWwsIG9iajogVCk6IFByb21pc2U8dm9pZD5cblxuICAgLyoqXG4gICAgKiBEZWxldGVzIGFuIE9iamVjdCBmcm9tIHRoZSBiYWNrZW5kXG4gICAgKiBcbiAgICAqIEBwYXJhbSBtb2RlbCBUaGUgTW9kZWxcbiAgICAqIEBwYXJhbSBvYmogVGhlIE9iamVjdCB0byBkZWxldGVcbiAgICAqL1xuICAgZGVsZXRlT2JqZWN0PFQgZXh0ZW5kcyBTdGFja09iamVjdD4obW9kZWw6IElNb2RlbCwgb2JqOiBUKTogUHJvbWlzZTx2b2lkPlxuXG4gICAvKipcbiAgICAqIFJldHJpZXZlcyBtYW55IG9iamVjdHMgaW4gYSBwYWdlZCBmYXNoaW9uLlxuICAgICogXG4gICAgKiBAcGFyYW0gbW9kZWwgVGhlIE1vZGVsIHJlcHJlc2VudGluZyB0aGUgT2JqZWN0c1xuICAgICogQHBhcmFtIG9wdGlvbnMgUGFnZVJlcXVlc3QgT3B0aW9uc1xuICAgICovXG4gICBnZXRNYW55T2JqZWN0czxUIGV4dGVuZHMgU3RhY2tPYmplY3Q+KG1vZGVsOiBJTW9kZWwsIG9wdGlvbnM6IFBhZ2VSZXF1ZXN0KTogUHJvbWlzZTxQYWdlUmVzcG9uc2U8VD4+XG4gICBcbiAgIC8qKlxuICAgICogUmV0cmlldmVzIHRoZSBFZGl0IHZlcnNpb24gb2YgdGhlIE9iamVjdFxuICAgICogXG4gICAgKiBAcGFyYW0gbW9kZWwgVGhlIE1vZGVsIG9mIHRoZSBPYmplY3RcbiAgICAqIEBwYXJhbSBpZCBUaGUgT2JqZWN0J3MgSURcbiAgICAqL1xuICAgZ2V0T2JqZWN0PFQgZXh0ZW5kcyBTdGFja09iamVjdD4obW9kZWw6IElNb2RlbCwgaWQ6IHN0cmluZyk6IFByb21pc2U8VCB8IHVuZGVmaW5lZD5cblxuICAgLyoqXG4gICAgKiBEZXRlcm1pbmVzIGlmIGFuIElEIGlzIGFscmVhZHkgaW4gdXNlLlxuICAgICogXG4gICAgKiBAcGFyYW0gaWQgVGhlIElEIHRvIHRlc3RcbiAgICAqIEBwYXJhbSBtb2RlbCBUaGUgYXNzb2NpYXRlZCBNb2RlbFxuICAgICovXG4gICBoYXNJZChpZDogc3RyaW5nLCBtb2RlbDogSU1vZGVsKTogUHJvbWlzZTxib29sZWFuPlxuICAgXG4gICAvKipcbiAgICAqIENyZWF0ZXMgYW5kIHN0b3JlcyBhIGN1c3RvbSBRdWVyeSBPYmplY3RcbiAgICAqIFxuICAgICogQHBhcmFtIGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gY3JlYXRlIHRoZSBjdXN0b20gUXVlcnkgT2JqZWN0XG4gICAgKi9cbiAgICBzdG9yZVF1ZXJ5T2JqZWN0PFQ+KGhhbmRsZXI6IEFwcGx5U3RvcmVDb250ZXh0SGFuZGxlcjxUPik6IFByb21pc2U8VCB8IHVuZGVmaW5lZD5cblxuICAgLyoqXG4gICAgKiBVcGRhdGVzIGFuIGFscmVhZHkgZXhpc3Rpbmcgb2JqZWN0IHdpdGggdGhlIGxhdGVzdCBmcm9tIHRoZSBzdG9yZWQgdmVyc2lvbi5cbiAgICAqIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgb24gbG9uZyBsaXZlZCBvYmplY3RzIHdoZXJlIHdlIHdhbnQgdGhlbVxuICAgICogdG8gYmUgdXBkYXRlZCBsb2NhbGx5LCBhbmQgbm90IHNhdmVkLlxuICAgICogXG4gICAgKiBAcGFyYW0gbW9kZWwgVGhlIE1vZGVsXG4gICAgKiBAcGFyYW0gb2JqIFRoZSBPYmplY3RcbiAgICAqIEBwYXJhbSBvblVwZGF0ZSBGdW5jdGlvbiB0byB1cGRhdGUgdGhlIE9iamVjdCBiYXNlZCBvbiB0aGUgbGF0ZXN0IHZlcnNpb25cbiAgICAqL1xuICAgdXBkYXRlT2JqZWN0PFQgZXh0ZW5kcyBTdGFja09iamVjdD4obW9kZWw6IElNb2RlbCwgb2JqOiBULCBvblVwZGF0ZTogVXBkYXRlT2JqZWN0SGFuZGxlcjxUPik6IFByb21pc2U8dm9pZD5cbn1cblxuXG5leHBvcnQgY2xhc3MgT3JjaGVzdHJhdG9yIGltcGxlbWVudHMgSU9yY2hlc3RyYXRvciB7XG4gICBnZXQgY2FjaGUoKTogSUNhY2hlIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuY2FjaGVcbiAgIH1cblxuICAgZ2V0IHJmYygpOiBJUmVxdWVzdEZvckNoYW5nZVNvdXJjZSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnJmY1xuICAgfVxuXG4gICBnZXQgc2VyaWFsaXplcigpOiBJVmFsdWVTZXJpYWxpemVyIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuc2VyaWFsaXplclxuICAgfVxuXG4gICBnZXQgc3RhY2soKTogSVN0YWNrIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuc3RhY2tcbiAgIH1cblxuICAgZ2V0IHVpZCgpOiBJVWlkS2VlcGVyIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQudWlkXG4gICB9XG5cbiAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGNvbnRleHQ6IElTdGFja0NvbnRleHQpIHtcblxuICAgfVxuXG4gICBhc3luYyBib29zdHJhcCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGF3YWl0IHRoaXMucmZjLmNyZWF0ZShuZXcgQm9vdHN0cmFwRXZlbnQoKSlcbiAgICAgICAgIC5mdWxmaWxsKGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGFjay5lbWl0KEV2ZW50U2V0LkJvb3RzdHJhcCwgZXZlbnQpXG4gICAgICAgICB9KVxuICAgICAgICAgLmNvbW1pdCgpXG4gICB9XG5cbiAgIGFzeW5jIGNyZWF0ZU1vZGVsKG5hbWU6IHN0cmluZywgcGFyYW1zOiBNb2RlbENyZWF0ZVBhcmFtcyk6IFByb21pc2U8SU1vZGVsPiB7XG4gICAgICBsZXQgbW9kZWwgPSBhd2FpdCB0aGlzLnN0YWNrLmdldC5tb2RlbChuYW1lKVxuXG4gICAgICBpZihtb2RlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgTW9kZWwgd2l0aCB0aGUgbmFtZSAke25hbWV9IGFscmVhZHkgZXhpc3RzYClcbiAgICAgIH1cblxuICAgICAgbW9kZWwgPSBhd2FpdCBNb2RlbC5jcmVhdGUobmFtZSwgdGhpcy5jb250ZXh0KVxuICAgICAgYXdhaXQgbW9kZWwuYXBwZW5kKHBhcmFtcylcblxuICAgICAgdGhpcy5jYWNoZS5zYXZlTW9kZWwobW9kZWwpXG5cbiAgICAgIGF3YWl0IHRoaXMucmZjLmNyZWF0ZShuZXcgTW9kZWxDcmVhdGVFdmVudChtb2RlbCkpXG4gICAgICAgICAuZnVsZmlsbChhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RhY2suZW1pdChFdmVudFNldC5Nb2RlbENyZWF0ZWQsIGV2ZW50KVxuICAgICAgICAgfSlcbiAgICAgICAgIC5jb21taXQoKVxuXG4gICAgICByZXR1cm4gbW9kZWxcbiAgIH1cblxuICAgYXN5bmMgZGVsZXRlTW9kZWwobW9kZWw6IElNb2RlbCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgYXdhaXQgdGhpcy5yZmMuY3JlYXRlKG5ldyBNb2RlbERlbGV0ZUV2ZW50KG1vZGVsKSlcbiAgICAgICAgIC5mdWxmaWxsKCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlTW9kZWwobW9kZWwubmFtZSlcbiAgICAgICAgIH0pXG4gICAgICAgICAuY29tbWl0KClcbiAgIH1cblxuICAgLy8gTm90ZTogVGhpcyBtYXkgbm90IGJlIG5lZWRlZC4gV2F0Y2ggZm9yIHRoaXMuXG4gICAvLyBNb2RlbCdzIGFyZSBzdG9yZWQgaW4gbG9jYWwgY2FjaGUgYmVjYXVzZSB0aGV5IGFyZVxuICAgLy8gZGVmaW5lZCBsb2NhbGx5LCBhbmQgYXJlIHRoZSBjb250cmFjdCBiZXR3ZWVuIHRoZVxuICAgLy8gdGhlIGV4cGVjdGVkIGRhdGEgc2V0IGFuZCB3aGF0IGlzIHN0b3JlZC5cbiAgIGFzeW5jIGdldE1vZGVsKG5hbWU6IHN0cmluZyk6IFByb21pc2U8SU1vZGVsIHwgdW5kZWZpbmVkPiB7XG4gICAgICBsZXQgbW9kZWw6IElNb2RlbCB8IHVuZGVmaW5lZFxuXG4gICAgICBhd2FpdCB0aGlzLnJmYy5jcmVhdGUobmV3IEdldE1vZGVsRXZlbnQobmFtZSkpXG4gICAgICAgICAuZnVsZmlsbChhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBnZXRNb2RlbCA9IGV2ZW50IGFzIEdldE1vZGVsRXZlbnRcbiAgICAgICAgICAgIG1vZGVsID0gZ2V0TW9kZWwubW9kZWwgfHwgdGhpcy5jYWNoZS5nZXRNb2RlbChuYW1lKVxuXG4gICAgICAgICAgICBpZihtb2RlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICB0aGlzLmNhY2hlLnNhdmVNb2RlbChtb2RlbClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGFjay5lbWl0KEV2ZW50U2V0LkdldE1vZGVsLCBldmVudClcbiAgICAgICAgIH0pXG4gICAgICAgICAuY29tbWl0KClcblxuICAgICAgcmV0dXJuIG1vZGVsXG4gICB9XG5cbiAgIGFzeW5jIHVwZGF0ZU1vZGVsKG1vZGVsOiBJTW9kZWwsIHBhcmFtczogTW9kZWxDcmVhdGVQYXJhbXMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIHRoaXMucmZjLmNyZWF0ZShuZXcgTW9kZWxVcGRhdGVFdmVudChtb2RlbCkpXG4gICAgICAgICAuZnVsZmlsbChhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB1cGRhdGVNb2RlbEV2ZW50ID0gZXZlbnQgYXMgTW9kZWxVcGRhdGVFdmVudFxuICAgICAgICAgICAgdGhpcy5jYWNoZS5zYXZlTW9kZWwodXBkYXRlTW9kZWxFdmVudC5tb2RlbClcbiAgICAgICAgIH0pXG4gICAgICAgICAuY29tbWl0KClcbiAgIH1cblxuICAgYXN5bmMgY3JlYXRlT2JqZWN0PFQgZXh0ZW5kcyBTdGFja09iamVjdD4obW9kZWw6IElNb2RlbCwgcGFyYW1zOiBPYmplY3RDcmVhdGVQYXJhbXMpOiBQcm9taXNlPFQ+IHtcbiAgICAgIGxldCBjcmVhdGVkID0gYXdhaXQgUHJveHlPYmplY3QuZnJvbUNyZWF0ZWQ8VD4obW9kZWwsIHBhcmFtcywgdGhpcy5jb250ZXh0KSBhcyBUXG5cbiAgICAgIGF3YWl0IHRoaXMucmZjLmNyZWF0ZShuZXcgT2JqZWN0Q3JlYXRlRXZlbnQobW9kZWwsIGNyZWF0ZWQpKVxuICAgICAgICAgLmZ1bGZpbGwoYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0YWNrLmVtaXQoRXZlbnRTZXQuT2JqZWN0Q3JlYXRlZCwgZXZlbnQpXG4gICAgICAgICB9KVxuICAgICAgICAgLmNvbW1pdCgpXG5cbiAgICAgIHJldHVybiBjcmVhdGVkXG4gICB9XG5cbiAgIC8qKlxuICAgICogXG4gICAgKiBAcGFyYW0gbW9kZWwgVGhlIE1vZGVsXG4gICAgKiBAcGFyYW0gb2JqIFRoZSBPYmplY3QgdG8gc2F2ZS4gTm90ZSB0aGF0IHRoaXMgaXMgcmVhbGx5IGEgUHJveHknZCBTZXJpYWxpemFibGVPYmplY3RcbiAgICAqL1xuICAgYXN5bmMgc2F2ZU9iamVjdDxUIGV4dGVuZHMgU3RhY2tPYmplY3Q+KG1vZGVsOiBJTW9kZWwsIG9iajogVCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYob2JqLmlkID09PSBVaWRLZWVwZXIuSWROb3RTZXQpIHtcbiAgICAgICAgIG9iai5pZCA9IGF3YWl0IHRoaXMudWlkLmdlbmVyYXRlKG1vZGVsKVxuICAgICAgfVxuICAgICAgXG4gICAgICBsZXQgdmFsaWRhdGlvbnMgPSBhd2FpdCBtb2RlbC52YWxpZGF0ZShvYmopXG5cbiAgICAgIGlmICghdmFsaWRhdGlvbnMuc3VjY2Vzcykge1xuICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgU2F2ZSBPYmplY3Qgd2l0aCBJRCAke29iai5pZH0gc2luY2UgaXQgZmFpbHMgdmFsaWRhdGlvbi4gUmVhc29uOiAke3ZhbGlkYXRpb25zLnJlc3VsdHMubWFwKHIgPT4gci5lcnJvcil9YClcbiAgICAgIH1cblxuICAgICAgLy9AdHMtaWdub3JlXG4gICAgICBsZXQgc2VyaWFsaXplZCA9IFByb3h5T2JqZWN0LnVud3JhcChvYmopXG5cbiAgICAgIGF3YWl0IHRoaXMucmZjLmNyZWF0ZShuZXcgT2JqZWN0U2F2ZUV2ZW50PFQ+KG1vZGVsLCBvYmosIHNlcmlhbGl6ZWQpKVxuICAgICAgICAgLmZ1bGZpbGwoYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLnNhdmVPYmplY3QobW9kZWwsIG9iailcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RhY2suZW1pdChFdmVudFNldC5PYmplY3RTYXZlZCwgZXZlbnQpXG4gICAgICAgICB9KVxuICAgICAgICAgLmNvbW1pdCgpXG4gICB9XG5cbiAgIGFzeW5jIGdldE1hbnlPYmplY3RzPFQgZXh0ZW5kcyBTdGFja09iamVjdD4obW9kZWw6IElNb2RlbCwgb3B0aW9uczogUGFnZVJlcXVlc3QgPSB7IGN1cnNvcjogJycsIGxpbWl0OiAxMDAgfSk6IFByb21pc2U8UGFnZVJlc3BvbnNlPFQ+PiB7XG4gICAgICBsZXQgcmVzdWx0cyA9IHtcbiAgICAgICAgIGN1cnNvcjogJycsXG4gICAgICAgICBpdGVtczogbmV3IEFycmF5PFQ+KClcbiAgICAgIH1cblxuICAgICAgYXdhaXQgdGhpcy5yZmMuY3JlYXRlKG5ldyBHZXRNYW55T2JqZWN0c0V2ZW50KG1vZGVsLCBvcHRpb25zKSlcbiAgICAgICAgIC5mdWxmaWxsKGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNhc3QgPSBldmVudCBhcyBHZXRNYW55T2JqZWN0c0V2ZW50PFQ+XG5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RhY2suZW1pdChFdmVudFNldC5HZXRNYW55T2JqZWN0cywgY2FzdClcblxuICAgICAgICAgICAgaWYgKGNhc3QucmVzdWx0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICByZXN1bHRzID0gY2FzdC5yZXN1bHRzXG4gICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG9iamVjdHMgPSB0aGlzLmNhY2hlLmdldE9iamVjdHM8VD4obW9kZWwpXG5cbiAgICAgICAgICAgIGlmIChvYmplY3RzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGN1cnNvciA9IG9wdGlvbnMuY3Vyc29yIHx8ICcnXG4gICAgICAgICAgICBsZXQgbGltaXQgPSBvcHRpb25zLmxpbWl0IHx8IDEwMFxuXG4gICAgICAgICAgICAvLyBTb3J0IGJ5IElELiBUaGUgcmVzdWx0aW5nIHBhZ2VkIHNldCBpcyBub3QgcGVyZmVjdCwgYW5kIHdpbGwgaGF2ZVxuICAgICAgICAgICAgLy8gaG9sZXMgd2hlbiBuZXcgZW50cmllcyBhcmUgYWRkZWQgaW4gYmV0d2VlbiBxdWVyaWVzLlxuICAgICAgICAgICAgb2JqZWN0cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICBsZXQgYUlkID0gYS5pZC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICBsZXQgYklkID0gYi5pZC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICByZXR1cm4gKGFJZCA8IGJJZCkgPyAtMSA6IChhSWQgPiBiSWQpID8gMSA6IDBcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIGlmIChjdXJzb3IgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAvLyBGb3IgYW4gZW1wdHkgY3Vyc29yIHdlIHN0YXJ0IGZyb20gdGhlIGJlZ2lubmluZ1xuICAgICAgICAgICAgICAgbGV0IGl0ZW1zID0gb2JqZWN0cy5zbGljZSgwLCBNYXRoLm1pbihvYmplY3RzLmxlbmd0aCwgbGltaXQpKVxuXG4gICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09IGxpbWl0ICYmIG9iamVjdHMubGVuZ3RoID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMuY3Vyc29yID0gQnVmZmVyLmZyb20ob2JqZWN0c1tsaW1pdF0uaWQpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBtb3JlIGVudHJpZXMgaW4gdGhlbmV4dCBzZXQsIHdlIGRlZmF1bHQgdGhlIGN1cnNvclxuICAgICAgICAgICAgICAgICAgLy8gdG8gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICAgICAgICByZXN1bHRzLmN1cnNvciA9ICcnXG4gICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgIHJlc3VsdHMuaXRlbXMgPSBpdGVtc1xuICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIGN1cnNvciBhbmQgY29udGludWUgZnJvbSB3aGVuY2Ugd2UgbGVmdCBvZmZcbiAgICAgICAgICAgICAgIGN1cnNvciA9IEJ1ZmZlci5mcm9tKGN1cnNvciwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdhc2NpaScpXG5cbiAgICAgICAgICAgICAgIGxldCBpbmRleCA9IG9iamVjdHMuZmluZEluZGV4KG8gPT4gby5pZCA9PT0gY3Vyc29yKVxuXG4gICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSB3aGVuIHRoZSBvYmplY3QgdGhhdCdzIG5leHQgaGFzIGJlZW4gZGVsZXRlZFxuICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIGVhcmx5XG4gICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgbGV0IG5leHRJbmRleCA9IGluZGV4ICsgbGltaXRcbiAgICAgICAgICAgICAgIHJlc3VsdHMuaXRlbXMgPSBvYmplY3RzLnNsaWNlKGluZGV4LCBuZXh0SW5kZXgpXG5cbiAgICAgICAgICAgICAgIGlmIChvYmplY3RzLmxlbmd0aCA+IG5leHRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5jdXJzb3IgPSBCdWZmZXIuZnJvbShvYmplY3RzW25leHRJbmRleF0uaWQpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBtb3JlIGVudHJpZXMgaW4gdGhlIG5leHQgc2V0LCB3ZSBkZWZhdWx0IHRoZSBjdXJzb3JcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5jdXJzb3IgPSAnJ1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICB9KVxuICAgICAgICAgLmNvbW1pdCgpXG5cbiAgICAgIHJldHVybiByZXN1bHRzXG4gICB9XG5cbiAgIGFzeW5jIGRlbGV0ZU9iamVjdDxUIGV4dGVuZHMgU3RhY2tPYmplY3Q+KG1vZGVsOiBJTW9kZWwsIG9iajogVCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgYXdhaXQgdGhpcy5yZmMuY3JlYXRlKG5ldyBPYmplY3REZWxldGVFdmVudChtb2RlbCwgb2JqKSlcbiAgICAgICAgIC5mdWxmaWxsKGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5kZWxldGVPYmplY3QobW9kZWwsIG9iailcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RhY2suZW1pdChFdmVudFNldC5PYmplY3REZWxldGVkLCBldmVudClcbiAgICAgICAgIH0pXG4gICAgICAgICAuY29tbWl0KClcbiAgIH1cblxuICAgYXN5bmMgZ2V0T2JqZWN0PFQgZXh0ZW5kcyBTdGFja09iamVjdD4obW9kZWw6IElNb2RlbCwgaWQ6IHN0cmluZyk6IFByb21pc2U8VCB8IHVuZGVmaW5lZD4ge1xuICAgICAgbGV0IG9iamVjdDogVCB8IHVuZGVmaW5lZFxuXG4gICAgICBhd2FpdCB0aGlzLnJmYy5jcmVhdGUobmV3IEdldE9iamVjdEV2ZW50KG1vZGVsLCBpZCkpXG4gICAgICAgICAuZnVsZmlsbChhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBjYXN0ID0gZXZlbnQgYXMgR2V0T2JqZWN0RXZlbnQ8VD5cblxuICAgICAgICAgICAgaWYgKGNhc3Qub2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgIG9iamVjdCA9IGNhc3QuZXhpc3RzID09PSBFeGlzdFN0YXRlLkRvZXNOb3RFeGlzdCA/XG4gICAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5nZXRPYmplY3QobW9kZWwsIGlkKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIC8vIFdlIGdldCBhIHNlcmlhbGl6ZWQgdmVyc2lvbiBvZiB0aGUgT2JqZWN0XG4gICAgICAgICAgICAgICBsZXQgc2VyaWFsaXplZCA9IGF3YWl0IFByb3h5T2JqZWN0LmZyb21TdG9yZWQobW9kZWwsIGNhc3Qub2JqZWN0LCB0aGlzLmNvbnRleHQuc2VyaWFsaXplcilcbiAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuc2F2ZU9iamVjdChtb2RlbCwgc2VyaWFsaXplZClcblxuICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICAgICBvYmplY3QgPSBzZXJpYWxpemVkIGFzIFRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGFjay5lbWl0KEV2ZW50U2V0LkdldE9iamVjdCwgZXZlbnQpXG4gICAgICAgICB9KVxuICAgICAgICAgLmNvbW1pdCgpXG5cbiAgICAgIHJldHVybiBvYmplY3RcbiAgIH1cblxuICAgYXN5bmMgaGFzSWQoaWQ6IHN0cmluZywgbW9kZWw6IElNb2RlbCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgbGV0IGhhc0lkID0gZmFsc2VcblxuICAgICAgYXdhaXQgdGhpcy5yZmMuY3JlYXRlKG5ldyBIYXNJZEV2ZW50KGlkLCBtb2RlbCkpXG4gICAgICAgICAuZnVsZmlsbChhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBjYXN0ID0gZXZlbnQgYXMgSGFzSWRFdmVudFxuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0YWNrLmVtaXQoRXZlbnRTZXQuSGFzSWQsIGV2ZW50KVxuXG4gICAgICAgICAgICBpZiAoY2FzdC5oYXNJZCkge1xuICAgICAgICAgICAgICAgaGFzSWQgPSB0cnVlXG4gICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGFzIGl0IGEgcGx1Z2luIGF0dGVtcHRlZCB0byBzZXQgaXQ/XG4gICAgICAgICAgICBpZiAoY2FzdC5hdHRlbXB0ZWRTZXQpIHtcbiAgICAgICAgICAgICAgIC8vIElmIHNvLCB3ZSBjYW4gdHJ1c3QgdGhhdCBhbiBleHRlcm5hbCBzeXN0ZW0gZG9lc24ndCBoYXZlIGl0XG4gICAgICAgICAgICAgICBoYXNJZCA9IGZhbHNlXG4gICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm8gZXh0ZXJuYWwgc3lzdGVtIGF0dGVtcHRlZCB0byBzZXQgaXQsIGRvIHdlIGhhdmUgaXQgY2FjaGVkP1xuICAgICAgICAgICAgaGFzSWQgPSB0aGlzLmNhY2hlLmhhc0lkKGlkKVxuXG4gICAgICAgICB9KVxuICAgICAgICAgLmNvbW1pdCgpXG5cbiAgICAgIHJldHVybiBoYXNJZFxuICAgfVxuXG4gICBhc3luYyBzdG9yZVF1ZXJ5T2JqZWN0PFQ+KGhhbmRsZXI6IEFwcGx5U3RvcmVDb250ZXh0SGFuZGxlcjxUPik6IFByb21pc2U8VCB8IHVuZGVmaW5lZD4ge1xuICAgICAgbGV0IHJlc3VsdDogVCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuXG4gICAgICBhd2FpdCB0aGlzLnJmYy5jcmVhdGUobmV3IEdldFN0b3JlQ29udGV4dEV2ZW50KCkpXG4gICAgICAgICAuZnVsZmlsbChhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBnZXRTdG9yZUNvbnRleHQgPSBldmVudCBhcyBHZXRTdG9yZUNvbnRleHRFdmVudFxuXG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBoYW5kbGVyKGdldFN0b3JlQ29udGV4dC5jb250ZXh0cylcbiAgICAgICAgIH0pXG4gICAgICAgICAuY29tbWl0KClcblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgfVxuXG4gICAvKipcbiAgICAqIFVwZGF0ZXMgYW4gYWxyZWFkeSBleGlzdGluZyBvYmplY3Qgd2l0aCB0aGUgbGF0ZXN0IGZyb20gdGhlIHN0b3JlZCB2ZXJzaW9uLlxuICAgICogVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBvbiBsb25nIGxpdmVkIG9iamVjdHMgd2hlcmUgd2Ugd2FudCB0aGVtXG4gICAgKiB0byBiZSB1cGRhdGVkIGxvY2FsbHksIGFuZCBub3Qgc2F2ZWQuXG4gICAgKiBcbiAgICAqIEBwYXJhbSBtb2RlbCBUaGUgTW9kZWxcbiAgICAqIEBwYXJhbSBvYmogVGhlIE9iamVjdFxuICAgICogQHBhcmFtIG9uVXBkYXRlIEZ1bmN0aW9uIHRvIHVwZGF0ZSB0aGUgT2JqZWN0IGJhc2VkIG9uIHRoZSBsYXRlc3QgdmVyc2lvblxuICAgICovXG4gICBhc3luYyB1cGRhdGVPYmplY3Q8VCBleHRlbmRzIFN0YWNrT2JqZWN0Pihtb2RlbDogSU1vZGVsLCBvYmo6IFQsIG9uVXBkYXRlOiBVcGRhdGVPYmplY3RIYW5kbGVyPFQ+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBhd2FpdCB0aGlzLnJmYy5jcmVhdGUobmV3IE9iamVjdFVwZGF0ZUV2ZW50PFQ+KG1vZGVsLCBvYmosIFByb3h5T2JqZWN0LnVud3JhcChvYmopKSlcbiAgICAgICAgIC5mdWxmaWxsKGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNhc3QgPSBldmVudCBhcyBPYmplY3RVcGRhdGVFdmVudDxUPlxuXG4gICAgICAgICAgICBsZXQgdXBkYXRlZCA9IGNhc3QudXBkYXRlZFxuXG4gICAgICAgICAgICBhd2FpdCBvblVwZGF0ZSh1cGRhdGVkLCBjYXN0LmV4aXN0cylcblxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGFjay5lbWl0KEV2ZW50U2V0Lk9iamVjdFVwZGF0ZWQsIGV2ZW50KVxuICAgICAgICAgfSlcbiAgICAgICAgIC5jb21taXQoKVxuICAgfVxufSJdfQ==